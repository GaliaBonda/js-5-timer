{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/moment/moment.js","src/main.ts","src/timer.ts"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtiLA,IAAA,UAAA,QAAA,SAAA,CAAA;AAEA,QAAA,QAAA;;;;;;;ACFA;AACA,IAAA,SAAA,QAAA,+BAAA,CAAA;AAEA,IAAM,aAA+B,SAAS,cAAT,CAAwB,aAAxB,CAArC;AACA,IAAM,eAAe,SAAS,cAAT,CAAwB,gBAAxB,CAArB;AACA,IAAM,eAAe,SAAS,cAAT,CAAwB,gBAAxB,CAArB;AAEA,aAAa,OAAb,GAAuB,YAAK;AAC1B,QAAI,CAAC,WAAW,KAAhB,EAAuB;AACrB,mBAAW,KAAX,GAAmB,GAAnB;AACD;AACD,QAAI,YAAY,SAAS,WAAW,KAApB,EAA2B,EAA3B,CAAhB;AACA,iBAAa,CAAb;AACA,eAAW,KAAX,GAAmB,UAAU,QAAV,EAAnB;AACD,CAPD;AAQA,aAAa,OAAb,GAAuB,YAAK;AAC1B,QAAI,YAAY,SAAS,WAAW,KAApB,EAA2B,EAA3B,CAAhB;AACA,QAAI,YAAY,CAAhB,EAAmB;AACjB,qBAAa,CAAb;AACA,mBAAW,KAAX,GAAmB,UAAU,QAAV,EAAnB;AACD,KAHD,MAGO;AACL,cAAM,6CAAN;AACD;AACF,CARD;AAUA,WAAW,OAAX,GAAqB,YAAK;AACxB,QAAI,OAAO,KAAP,CAAa,SAAS,WAAW,KAApB,EAA2B,EAA3B,CAAb,CAAJ,EAAkD;AAChD,cAAM,4BAAN;AACA,mBAAW,KAAX,GAAmB,GAAnB;AACD;AACF,CALD;AAOA,SAAgB,QAAhB,GAAwB;AACtB,QAAI,kBAAJ;AACA,QAAM,QAAQ,SAAS,cAAT,CAAwB,OAAxB,CAAd;AACA,UAAM,OAAN,GAAgB,YAAK;AACnB,oBAAY,WAAW,KAAvB;AACA,YAAM,OAAO,OAAO,EAAE,QAAQ,SAAS,SAAT,EAAoB,EAApB,CAAV,EAAmC,QAAQ,CAA3C,EAAP,CAAb;AACA,YAAM,YAAY,SAAS,cAAT,CAAwB,YAAxB,CAAlB;AACA,kBAAU,SAAV,GAAsB,WAAtB;AACA,YAAM,YAAY,SAAS,cAAT,CAAwB,YAAxB,CAAlB;AACA,kBAAU,KAAV,CAAgB,OAAhB,GAA0B,MAA1B;AACA,cAAM,KAAN,CAAY,OAAZ,GAAsB,MAAtB;AACA,YAAM,cAAc,SAAS,aAAT,CAAuB,KAAvB,CAApB;AACA,oBAAY,SAAZ,CAAsB,GAAtB,CAA0B,cAA1B;AACA,YAAM,QAAQ,SAAS,cAAT,CAAwB,OAAxB,CAAd;AACA,cAAM,WAAN,CAAkB,WAAlB;AAEA,oBAAY,SAAZ,GAAwB,KAAK,MAAL,CAAY,OAAZ,CAAxB;AACA,YAAM,SAAS,YAAY,YAAK;AAC9B,gBAAM,UAAU,KAAK,QAAL,CAAc,CAAd,EAAiB,SAAjB,CAAhB;AACA,wBAAY,SAAZ,GAAwB,QAAQ,MAAR,CAAe,OAAf,CAAxB;AACD,SAHc,EAGZ,IAHY,CAAf;AAIA,mBAAW,YAAK;AACd,0BAAc,MAAd;AACD,SAFD,EAEG,SAAS,SAAT,EAAoB,EAApB,IAA0B,IAA1B,GAAiC,EAFpC;AAGD,KArBD;AAsBD;AAzBD,QAAA,QAAA,GAAA,QAAA","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","//! moment.js\r\n//! version : 2.29.1\r\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\r\n//! license : MIT\r\n//! momentjs.com\r\n\r\n;(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n    typeof define === 'function' && define.amd ? define(factory) :\r\n    global.moment = factory()\r\n}(this, (function () { 'use strict';\r\n\r\n    var hookCallback;\r\n\r\n    function hooks() {\r\n        return hookCallback.apply(null, arguments);\r\n    }\r\n\r\n    // This is done to register the method called with moment()\r\n    // without creating circular dependencies.\r\n    function setHookCallback(callback) {\r\n        hookCallback = callback;\r\n    }\r\n\r\n    function isArray(input) {\r\n        return (\r\n            input instanceof Array ||\r\n            Object.prototype.toString.call(input) === '[object Array]'\r\n        );\r\n    }\r\n\r\n    function isObject(input) {\r\n        // IE8 will treat undefined and null as object if it wasn't for\r\n        // input != null\r\n        return (\r\n            input != null &&\r\n            Object.prototype.toString.call(input) === '[object Object]'\r\n        );\r\n    }\r\n\r\n    function hasOwnProp(a, b) {\r\n        return Object.prototype.hasOwnProperty.call(a, b);\r\n    }\r\n\r\n    function isObjectEmpty(obj) {\r\n        if (Object.getOwnPropertyNames) {\r\n            return Object.getOwnPropertyNames(obj).length === 0;\r\n        } else {\r\n            var k;\r\n            for (k in obj) {\r\n                if (hasOwnProp(obj, k)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function isUndefined(input) {\r\n        return input === void 0;\r\n    }\r\n\r\n    function isNumber(input) {\r\n        return (\r\n            typeof input === 'number' ||\r\n            Object.prototype.toString.call(input) === '[object Number]'\r\n        );\r\n    }\r\n\r\n    function isDate(input) {\r\n        return (\r\n            input instanceof Date ||\r\n            Object.prototype.toString.call(input) === '[object Date]'\r\n        );\r\n    }\r\n\r\n    function map(arr, fn) {\r\n        var res = [],\r\n            i;\r\n        for (i = 0; i < arr.length; ++i) {\r\n            res.push(fn(arr[i], i));\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function extend(a, b) {\r\n        for (var i in b) {\r\n            if (hasOwnProp(b, i)) {\r\n                a[i] = b[i];\r\n            }\r\n        }\r\n\r\n        if (hasOwnProp(b, 'toString')) {\r\n            a.toString = b.toString;\r\n        }\r\n\r\n        if (hasOwnProp(b, 'valueOf')) {\r\n            a.valueOf = b.valueOf;\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function createUTC(input, format, locale, strict) {\r\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\r\n    }\r\n\r\n    function defaultParsingFlags() {\r\n        // We need to deep clone this object.\r\n        return {\r\n            empty: false,\r\n            unusedTokens: [],\r\n            unusedInput: [],\r\n            overflow: -2,\r\n            charsLeftOver: 0,\r\n            nullInput: false,\r\n            invalidEra: null,\r\n            invalidMonth: null,\r\n            invalidFormat: false,\r\n            userInvalidated: false,\r\n            iso: false,\r\n            parsedDateParts: [],\r\n            era: null,\r\n            meridiem: null,\r\n            rfc2822: false,\r\n            weekdayMismatch: false,\r\n        };\r\n    }\r\n\r\n    function getParsingFlags(m) {\r\n        if (m._pf == null) {\r\n            m._pf = defaultParsingFlags();\r\n        }\r\n        return m._pf;\r\n    }\r\n\r\n    var some;\r\n    if (Array.prototype.some) {\r\n        some = Array.prototype.some;\r\n    } else {\r\n        some = function (fun) {\r\n            var t = Object(this),\r\n                len = t.length >>> 0,\r\n                i;\r\n\r\n            for (i = 0; i < len; i++) {\r\n                if (i in t && fun.call(this, t[i], i, t)) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n    }\r\n\r\n    function isValid(m) {\r\n        if (m._isValid == null) {\r\n            var flags = getParsingFlags(m),\r\n                parsedParts = some.call(flags.parsedDateParts, function (i) {\r\n                    return i != null;\r\n                }),\r\n                isNowValid =\r\n                    !isNaN(m._d.getTime()) &&\r\n                    flags.overflow < 0 &&\r\n                    !flags.empty &&\r\n                    !flags.invalidEra &&\r\n                    !flags.invalidMonth &&\r\n                    !flags.invalidWeekday &&\r\n                    !flags.weekdayMismatch &&\r\n                    !flags.nullInput &&\r\n                    !flags.invalidFormat &&\r\n                    !flags.userInvalidated &&\r\n                    (!flags.meridiem || (flags.meridiem && parsedParts));\r\n\r\n            if (m._strict) {\r\n                isNowValid =\r\n                    isNowValid &&\r\n                    flags.charsLeftOver === 0 &&\r\n                    flags.unusedTokens.length === 0 &&\r\n                    flags.bigHour === undefined;\r\n            }\r\n\r\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\r\n                m._isValid = isNowValid;\r\n            } else {\r\n                return isNowValid;\r\n            }\r\n        }\r\n        return m._isValid;\r\n    }\r\n\r\n    function createInvalid(flags) {\r\n        var m = createUTC(NaN);\r\n        if (flags != null) {\r\n            extend(getParsingFlags(m), flags);\r\n        } else {\r\n            getParsingFlags(m).userInvalidated = true;\r\n        }\r\n\r\n        return m;\r\n    }\r\n\r\n    // Plugins that add properties should also add the key here (null value),\r\n    // so we can properly clone ourselves.\r\n    var momentProperties = (hooks.momentProperties = []),\r\n        updateInProgress = false;\r\n\r\n    function copyConfig(to, from) {\r\n        var i, prop, val;\r\n\r\n        if (!isUndefined(from._isAMomentObject)) {\r\n            to._isAMomentObject = from._isAMomentObject;\r\n        }\r\n        if (!isUndefined(from._i)) {\r\n            to._i = from._i;\r\n        }\r\n        if (!isUndefined(from._f)) {\r\n            to._f = from._f;\r\n        }\r\n        if (!isUndefined(from._l)) {\r\n            to._l = from._l;\r\n        }\r\n        if (!isUndefined(from._strict)) {\r\n            to._strict = from._strict;\r\n        }\r\n        if (!isUndefined(from._tzm)) {\r\n            to._tzm = from._tzm;\r\n        }\r\n        if (!isUndefined(from._isUTC)) {\r\n            to._isUTC = from._isUTC;\r\n        }\r\n        if (!isUndefined(from._offset)) {\r\n            to._offset = from._offset;\r\n        }\r\n        if (!isUndefined(from._pf)) {\r\n            to._pf = getParsingFlags(from);\r\n        }\r\n        if (!isUndefined(from._locale)) {\r\n            to._locale = from._locale;\r\n        }\r\n\r\n        if (momentProperties.length > 0) {\r\n            for (i = 0; i < momentProperties.length; i++) {\r\n                prop = momentProperties[i];\r\n                val = from[prop];\r\n                if (!isUndefined(val)) {\r\n                    to[prop] = val;\r\n                }\r\n            }\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    // Moment prototype object\r\n    function Moment(config) {\r\n        copyConfig(this, config);\r\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\r\n        if (!this.isValid()) {\r\n            this._d = new Date(NaN);\r\n        }\r\n        // Prevent infinite loop in case updateOffset creates new moment\r\n        // objects.\r\n        if (updateInProgress === false) {\r\n            updateInProgress = true;\r\n            hooks.updateOffset(this);\r\n            updateInProgress = false;\r\n        }\r\n    }\r\n\r\n    function isMoment(obj) {\r\n        return (\r\n            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)\r\n        );\r\n    }\r\n\r\n    function warn(msg) {\r\n        if (\r\n            hooks.suppressDeprecationWarnings === false &&\r\n            typeof console !== 'undefined' &&\r\n            console.warn\r\n        ) {\r\n            console.warn('Deprecation warning: ' + msg);\r\n        }\r\n    }\r\n\r\n    function deprecate(msg, fn) {\r\n        var firstTime = true;\r\n\r\n        return extend(function () {\r\n            if (hooks.deprecationHandler != null) {\r\n                hooks.deprecationHandler(null, msg);\r\n            }\r\n            if (firstTime) {\r\n                var args = [],\r\n                    arg,\r\n                    i,\r\n                    key;\r\n                for (i = 0; i < arguments.length; i++) {\r\n                    arg = '';\r\n                    if (typeof arguments[i] === 'object') {\r\n                        arg += '\\n[' + i + '] ';\r\n                        for (key in arguments[0]) {\r\n                            if (hasOwnProp(arguments[0], key)) {\r\n                                arg += key + ': ' + arguments[0][key] + ', ';\r\n                            }\r\n                        }\r\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\r\n                    } else {\r\n                        arg = arguments[i];\r\n                    }\r\n                    args.push(arg);\r\n                }\r\n                warn(\r\n                    msg +\r\n                        '\\nArguments: ' +\r\n                        Array.prototype.slice.call(args).join('') +\r\n                        '\\n' +\r\n                        new Error().stack\r\n                );\r\n                firstTime = false;\r\n            }\r\n            return fn.apply(this, arguments);\r\n        }, fn);\r\n    }\r\n\r\n    var deprecations = {};\r\n\r\n    function deprecateSimple(name, msg) {\r\n        if (hooks.deprecationHandler != null) {\r\n            hooks.deprecationHandler(name, msg);\r\n        }\r\n        if (!deprecations[name]) {\r\n            warn(msg);\r\n            deprecations[name] = true;\r\n        }\r\n    }\r\n\r\n    hooks.suppressDeprecationWarnings = false;\r\n    hooks.deprecationHandler = null;\r\n\r\n    function isFunction(input) {\r\n        return (\r\n            (typeof Function !== 'undefined' && input instanceof Function) ||\r\n            Object.prototype.toString.call(input) === '[object Function]'\r\n        );\r\n    }\r\n\r\n    function set(config) {\r\n        var prop, i;\r\n        for (i in config) {\r\n            if (hasOwnProp(config, i)) {\r\n                prop = config[i];\r\n                if (isFunction(prop)) {\r\n                    this[i] = prop;\r\n                } else {\r\n                    this['_' + i] = prop;\r\n                }\r\n            }\r\n        }\r\n        this._config = config;\r\n        // Lenient ordinal parsing accepts just a number in addition to\r\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\r\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\r\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\r\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\r\n                '|' +\r\n                /\\d{1,2}/.source\r\n        );\r\n    }\r\n\r\n    function mergeConfigs(parentConfig, childConfig) {\r\n        var res = extend({}, parentConfig),\r\n            prop;\r\n        for (prop in childConfig) {\r\n            if (hasOwnProp(childConfig, prop)) {\r\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\r\n                    res[prop] = {};\r\n                    extend(res[prop], parentConfig[prop]);\r\n                    extend(res[prop], childConfig[prop]);\r\n                } else if (childConfig[prop] != null) {\r\n                    res[prop] = childConfig[prop];\r\n                } else {\r\n                    delete res[prop];\r\n                }\r\n            }\r\n        }\r\n        for (prop in parentConfig) {\r\n            if (\r\n                hasOwnProp(parentConfig, prop) &&\r\n                !hasOwnProp(childConfig, prop) &&\r\n                isObject(parentConfig[prop])\r\n            ) {\r\n                // make sure changes to properties don't modify parent config\r\n                res[prop] = extend({}, res[prop]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function Locale(config) {\r\n        if (config != null) {\r\n            this.set(config);\r\n        }\r\n    }\r\n\r\n    var keys;\r\n\r\n    if (Object.keys) {\r\n        keys = Object.keys;\r\n    } else {\r\n        keys = function (obj) {\r\n            var i,\r\n                res = [];\r\n            for (i in obj) {\r\n                if (hasOwnProp(obj, i)) {\r\n                    res.push(i);\r\n                }\r\n            }\r\n            return res;\r\n        };\r\n    }\r\n\r\n    var defaultCalendar = {\r\n        sameDay: '[Today at] LT',\r\n        nextDay: '[Tomorrow at] LT',\r\n        nextWeek: 'dddd [at] LT',\r\n        lastDay: '[Yesterday at] LT',\r\n        lastWeek: '[Last] dddd [at] LT',\r\n        sameElse: 'L',\r\n    };\r\n\r\n    function calendar(key, mom, now) {\r\n        var output = this._calendar[key] || this._calendar['sameElse'];\r\n        return isFunction(output) ? output.call(mom, now) : output;\r\n    }\r\n\r\n    function zeroFill(number, targetLength, forceSign) {\r\n        var absNumber = '' + Math.abs(number),\r\n            zerosToFill = targetLength - absNumber.length,\r\n            sign = number >= 0;\r\n        return (\r\n            (sign ? (forceSign ? '+' : '') : '-') +\r\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +\r\n            absNumber\r\n        );\r\n    }\r\n\r\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\r\n        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\r\n        formatFunctions = {},\r\n        formatTokenFunctions = {};\r\n\r\n    // token:    'M'\r\n    // padded:   ['MM', 2]\r\n    // ordinal:  'Mo'\r\n    // callback: function () { this.month() + 1 }\r\n    function addFormatToken(token, padded, ordinal, callback) {\r\n        var func = callback;\r\n        if (typeof callback === 'string') {\r\n            func = function () {\r\n                return this[callback]();\r\n            };\r\n        }\r\n        if (token) {\r\n            formatTokenFunctions[token] = func;\r\n        }\r\n        if (padded) {\r\n            formatTokenFunctions[padded[0]] = function () {\r\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\r\n            };\r\n        }\r\n        if (ordinal) {\r\n            formatTokenFunctions[ordinal] = function () {\r\n                return this.localeData().ordinal(\r\n                    func.apply(this, arguments),\r\n                    token\r\n                );\r\n            };\r\n        }\r\n    }\r\n\r\n    function removeFormattingTokens(input) {\r\n        if (input.match(/\\[[\\s\\S]/)) {\r\n            return input.replace(/^\\[|\\]$/g, '');\r\n        }\r\n        return input.replace(/\\\\/g, '');\r\n    }\r\n\r\n    function makeFormatFunction(format) {\r\n        var array = format.match(formattingTokens),\r\n            i,\r\n            length;\r\n\r\n        for (i = 0, length = array.length; i < length; i++) {\r\n            if (formatTokenFunctions[array[i]]) {\r\n                array[i] = formatTokenFunctions[array[i]];\r\n            } else {\r\n                array[i] = removeFormattingTokens(array[i]);\r\n            }\r\n        }\r\n\r\n        return function (mom) {\r\n            var output = '',\r\n                i;\r\n            for (i = 0; i < length; i++) {\r\n                output += isFunction(array[i])\r\n                    ? array[i].call(mom, format)\r\n                    : array[i];\r\n            }\r\n            return output;\r\n        };\r\n    }\r\n\r\n    // format date using native date object\r\n    function formatMoment(m, format) {\r\n        if (!m.isValid()) {\r\n            return m.localeData().invalidDate();\r\n        }\r\n\r\n        format = expandFormat(format, m.localeData());\r\n        formatFunctions[format] =\r\n            formatFunctions[format] || makeFormatFunction(format);\r\n\r\n        return formatFunctions[format](m);\r\n    }\r\n\r\n    function expandFormat(format, locale) {\r\n        var i = 5;\r\n\r\n        function replaceLongDateFormatTokens(input) {\r\n            return locale.longDateFormat(input) || input;\r\n        }\r\n\r\n        localFormattingTokens.lastIndex = 0;\r\n        while (i >= 0 && localFormattingTokens.test(format)) {\r\n            format = format.replace(\r\n                localFormattingTokens,\r\n                replaceLongDateFormatTokens\r\n            );\r\n            localFormattingTokens.lastIndex = 0;\r\n            i -= 1;\r\n        }\r\n\r\n        return format;\r\n    }\r\n\r\n    var defaultLongDateFormat = {\r\n        LTS: 'h:mm:ss A',\r\n        LT: 'h:mm A',\r\n        L: 'MM/DD/YYYY',\r\n        LL: 'MMMM D, YYYY',\r\n        LLL: 'MMMM D, YYYY h:mm A',\r\n        LLLL: 'dddd, MMMM D, YYYY h:mm A',\r\n    };\r\n\r\n    function longDateFormat(key) {\r\n        var format = this._longDateFormat[key],\r\n            formatUpper = this._longDateFormat[key.toUpperCase()];\r\n\r\n        if (format || !formatUpper) {\r\n            return format;\r\n        }\r\n\r\n        this._longDateFormat[key] = formatUpper\r\n            .match(formattingTokens)\r\n            .map(function (tok) {\r\n                if (\r\n                    tok === 'MMMM' ||\r\n                    tok === 'MM' ||\r\n                    tok === 'DD' ||\r\n                    tok === 'dddd'\r\n                ) {\r\n                    return tok.slice(1);\r\n                }\r\n                return tok;\r\n            })\r\n            .join('');\r\n\r\n        return this._longDateFormat[key];\r\n    }\r\n\r\n    var defaultInvalidDate = 'Invalid date';\r\n\r\n    function invalidDate() {\r\n        return this._invalidDate;\r\n    }\r\n\r\n    var defaultOrdinal = '%d',\r\n        defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\r\n\r\n    function ordinal(number) {\r\n        return this._ordinal.replace('%d', number);\r\n    }\r\n\r\n    var defaultRelativeTime = {\r\n        future: 'in %s',\r\n        past: '%s ago',\r\n        s: 'a few seconds',\r\n        ss: '%d seconds',\r\n        m: 'a minute',\r\n        mm: '%d minutes',\r\n        h: 'an hour',\r\n        hh: '%d hours',\r\n        d: 'a day',\r\n        dd: '%d days',\r\n        w: 'a week',\r\n        ww: '%d weeks',\r\n        M: 'a month',\r\n        MM: '%d months',\r\n        y: 'a year',\r\n        yy: '%d years',\r\n    };\r\n\r\n    function relativeTime(number, withoutSuffix, string, isFuture) {\r\n        var output = this._relativeTime[string];\r\n        return isFunction(output)\r\n            ? output(number, withoutSuffix, string, isFuture)\r\n            : output.replace(/%d/i, number);\r\n    }\r\n\r\n    function pastFuture(diff, output) {\r\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\r\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\r\n    }\r\n\r\n    var aliases = {};\r\n\r\n    function addUnitAlias(unit, shorthand) {\r\n        var lowerCase = unit.toLowerCase();\r\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\r\n    }\r\n\r\n    function normalizeUnits(units) {\r\n        return typeof units === 'string'\r\n            ? aliases[units] || aliases[units.toLowerCase()]\r\n            : undefined;\r\n    }\r\n\r\n    function normalizeObjectUnits(inputObject) {\r\n        var normalizedInput = {},\r\n            normalizedProp,\r\n            prop;\r\n\r\n        for (prop in inputObject) {\r\n            if (hasOwnProp(inputObject, prop)) {\r\n                normalizedProp = normalizeUnits(prop);\r\n                if (normalizedProp) {\r\n                    normalizedInput[normalizedProp] = inputObject[prop];\r\n                }\r\n            }\r\n        }\r\n\r\n        return normalizedInput;\r\n    }\r\n\r\n    var priorities = {};\r\n\r\n    function addUnitPriority(unit, priority) {\r\n        priorities[unit] = priority;\r\n    }\r\n\r\n    function getPrioritizedUnits(unitsObj) {\r\n        var units = [],\r\n            u;\r\n        for (u in unitsObj) {\r\n            if (hasOwnProp(unitsObj, u)) {\r\n                units.push({ unit: u, priority: priorities[u] });\r\n            }\r\n        }\r\n        units.sort(function (a, b) {\r\n            return a.priority - b.priority;\r\n        });\r\n        return units;\r\n    }\r\n\r\n    function isLeapYear(year) {\r\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\r\n    }\r\n\r\n    function absFloor(number) {\r\n        if (number < 0) {\r\n            // -0 -> 0\r\n            return Math.ceil(number) || 0;\r\n        } else {\r\n            return Math.floor(number);\r\n        }\r\n    }\r\n\r\n    function toInt(argumentForCoercion) {\r\n        var coercedNumber = +argumentForCoercion,\r\n            value = 0;\r\n\r\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\r\n            value = absFloor(coercedNumber);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    function makeGetSet(unit, keepTime) {\r\n        return function (value) {\r\n            if (value != null) {\r\n                set$1(this, unit, value);\r\n                hooks.updateOffset(this, keepTime);\r\n                return this;\r\n            } else {\r\n                return get(this, unit);\r\n            }\r\n        };\r\n    }\r\n\r\n    function get(mom, unit) {\r\n        return mom.isValid()\r\n            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()\r\n            : NaN;\r\n    }\r\n\r\n    function set$1(mom, unit, value) {\r\n        if (mom.isValid() && !isNaN(value)) {\r\n            if (\r\n                unit === 'FullYear' &&\r\n                isLeapYear(mom.year()) &&\r\n                mom.month() === 1 &&\r\n                mom.date() === 29\r\n            ) {\r\n                value = toInt(value);\r\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](\r\n                    value,\r\n                    mom.month(),\r\n                    daysInMonth(value, mom.month())\r\n                );\r\n            } else {\r\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\r\n            }\r\n        }\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function stringGet(units) {\r\n        units = normalizeUnits(units);\r\n        if (isFunction(this[units])) {\r\n            return this[units]();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function stringSet(units, value) {\r\n        if (typeof units === 'object') {\r\n            units = normalizeObjectUnits(units);\r\n            var prioritized = getPrioritizedUnits(units),\r\n                i;\r\n            for (i = 0; i < prioritized.length; i++) {\r\n                this[prioritized[i].unit](units[prioritized[i].unit]);\r\n            }\r\n        } else {\r\n            units = normalizeUnits(units);\r\n            if (isFunction(this[units])) {\r\n                return this[units](value);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    var match1 = /\\d/, //       0 - 9\r\n        match2 = /\\d\\d/, //      00 - 99\r\n        match3 = /\\d{3}/, //     000 - 999\r\n        match4 = /\\d{4}/, //    0000 - 9999\r\n        match6 = /[+-]?\\d{6}/, // -999999 - 999999\r\n        match1to2 = /\\d\\d?/, //       0 - 99\r\n        match3to4 = /\\d\\d\\d\\d?/, //     999 - 9999\r\n        match5to6 = /\\d\\d\\d\\d\\d\\d?/, //   99999 - 999999\r\n        match1to3 = /\\d{1,3}/, //       0 - 999\r\n        match1to4 = /\\d{1,4}/, //       0 - 9999\r\n        match1to6 = /[+-]?\\d{1,6}/, // -999999 - 999999\r\n        matchUnsigned = /\\d+/, //       0 - inf\r\n        matchSigned = /[+-]?\\d+/, //    -inf - inf\r\n        matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, // +00:00 -00:00 +0000 -0000 or Z\r\n        matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z\r\n        matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\r\n        // any word (or two) characters or numbers including two/three word month in arabic.\r\n        // includes scottish gaelic two word and hyphenated months\r\n        matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\r\n        regexes;\r\n\r\n    regexes = {};\r\n\r\n    function addRegexToken(token, regex, strictRegex) {\r\n        regexes[token] = isFunction(regex)\r\n            ? regex\r\n            : function (isStrict, localeData) {\r\n                  return isStrict && strictRegex ? strictRegex : regex;\r\n              };\r\n    }\r\n\r\n    function getParseRegexForToken(token, config) {\r\n        if (!hasOwnProp(regexes, token)) {\r\n            return new RegExp(unescapeFormat(token));\r\n        }\r\n\r\n        return regexes[token](config._strict, config._locale);\r\n    }\r\n\r\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\r\n    function unescapeFormat(s) {\r\n        return regexEscape(\r\n            s\r\n                .replace('\\\\', '')\r\n                .replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (\r\n                    matched,\r\n                    p1,\r\n                    p2,\r\n                    p3,\r\n                    p4\r\n                ) {\r\n                    return p1 || p2 || p3 || p4;\r\n                })\r\n        );\r\n    }\r\n\r\n    function regexEscape(s) {\r\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n    }\r\n\r\n    var tokens = {};\r\n\r\n    function addParseToken(token, callback) {\r\n        var i,\r\n            func = callback;\r\n        if (typeof token === 'string') {\r\n            token = [token];\r\n        }\r\n        if (isNumber(callback)) {\r\n            func = function (input, array) {\r\n                array[callback] = toInt(input);\r\n            };\r\n        }\r\n        for (i = 0; i < token.length; i++) {\r\n            tokens[token[i]] = func;\r\n        }\r\n    }\r\n\r\n    function addWeekParseToken(token, callback) {\r\n        addParseToken(token, function (input, array, config, token) {\r\n            config._w = config._w || {};\r\n            callback(input, config._w, config, token);\r\n        });\r\n    }\r\n\r\n    function addTimeToArrayFromToken(token, input, config) {\r\n        if (input != null && hasOwnProp(tokens, token)) {\r\n            tokens[token](input, config._a, config, token);\r\n        }\r\n    }\r\n\r\n    var YEAR = 0,\r\n        MONTH = 1,\r\n        DATE = 2,\r\n        HOUR = 3,\r\n        MINUTE = 4,\r\n        SECOND = 5,\r\n        MILLISECOND = 6,\r\n        WEEK = 7,\r\n        WEEKDAY = 8;\r\n\r\n    function mod(n, x) {\r\n        return ((n % x) + x) % x;\r\n    }\r\n\r\n    var indexOf;\r\n\r\n    if (Array.prototype.indexOf) {\r\n        indexOf = Array.prototype.indexOf;\r\n    } else {\r\n        indexOf = function (o) {\r\n            // I know\r\n            var i;\r\n            for (i = 0; i < this.length; ++i) {\r\n                if (this[i] === o) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n    }\r\n\r\n    function daysInMonth(year, month) {\r\n        if (isNaN(year) || isNaN(month)) {\r\n            return NaN;\r\n        }\r\n        var modMonth = mod(month, 12);\r\n        year += (month - modMonth) / 12;\r\n        return modMonth === 1\r\n            ? isLeapYear(year)\r\n                ? 29\r\n                : 28\r\n            : 31 - ((modMonth % 7) % 2);\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\r\n        return this.month() + 1;\r\n    });\r\n\r\n    addFormatToken('MMM', 0, 0, function (format) {\r\n        return this.localeData().monthsShort(this, format);\r\n    });\r\n\r\n    addFormatToken('MMMM', 0, 0, function (format) {\r\n        return this.localeData().months(this, format);\r\n    });\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('month', 'M');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('month', 8);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('M', match1to2);\r\n    addRegexToken('MM', match1to2, match2);\r\n    addRegexToken('MMM', function (isStrict, locale) {\r\n        return locale.monthsShortRegex(isStrict);\r\n    });\r\n    addRegexToken('MMMM', function (isStrict, locale) {\r\n        return locale.monthsRegex(isStrict);\r\n    });\r\n\r\n    addParseToken(['M', 'MM'], function (input, array) {\r\n        array[MONTH] = toInt(input) - 1;\r\n    });\r\n\r\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\r\n        var month = config._locale.monthsParse(input, token, config._strict);\r\n        // if we didn't find a month name, mark the date as invalid.\r\n        if (month != null) {\r\n            array[MONTH] = month;\r\n        } else {\r\n            getParsingFlags(config).invalidMonth = input;\r\n        }\r\n    });\r\n\r\n    // LOCALES\r\n\r\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(\r\n            '_'\r\n        ),\r\n        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(\r\n            '_'\r\n        ),\r\n        MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\r\n        defaultMonthsShortRegex = matchWord,\r\n        defaultMonthsRegex = matchWord;\r\n\r\n    function localeMonths(m, format) {\r\n        if (!m) {\r\n            return isArray(this._months)\r\n                ? this._months\r\n                : this._months['standalone'];\r\n        }\r\n        return isArray(this._months)\r\n            ? this._months[m.month()]\r\n            : this._months[\r\n                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)\r\n                      ? 'format'\r\n                      : 'standalone'\r\n              ][m.month()];\r\n    }\r\n\r\n    function localeMonthsShort(m, format) {\r\n        if (!m) {\r\n            return isArray(this._monthsShort)\r\n                ? this._monthsShort\r\n                : this._monthsShort['standalone'];\r\n        }\r\n        return isArray(this._monthsShort)\r\n            ? this._monthsShort[m.month()]\r\n            : this._monthsShort[\r\n                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'\r\n              ][m.month()];\r\n    }\r\n\r\n    function handleStrictParse(monthName, format, strict) {\r\n        var i,\r\n            ii,\r\n            mom,\r\n            llc = monthName.toLocaleLowerCase();\r\n        if (!this._monthsParse) {\r\n            // this is not used\r\n            this._monthsParse = [];\r\n            this._longMonthsParse = [];\r\n            this._shortMonthsParse = [];\r\n            for (i = 0; i < 12; ++i) {\r\n                mom = createUTC([2000, i]);\r\n                this._shortMonthsParse[i] = this.monthsShort(\r\n                    mom,\r\n                    ''\r\n                ).toLocaleLowerCase();\r\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\r\n            }\r\n        }\r\n\r\n        if (strict) {\r\n            if (format === 'MMM') {\r\n                ii = indexOf.call(this._shortMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._longMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        } else {\r\n            if (format === 'MMM') {\r\n                ii = indexOf.call(this._shortMonthsParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._longMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._longMonthsParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._shortMonthsParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    function localeMonthsParse(monthName, format, strict) {\r\n        var i, mom, regex;\r\n\r\n        if (this._monthsParseExact) {\r\n            return handleStrictParse.call(this, monthName, format, strict);\r\n        }\r\n\r\n        if (!this._monthsParse) {\r\n            this._monthsParse = [];\r\n            this._longMonthsParse = [];\r\n            this._shortMonthsParse = [];\r\n        }\r\n\r\n        // TODO: add sorting\r\n        // Sorting makes sure if one month (or abbr) is a prefix of another\r\n        // see sorting in computeMonthsParse\r\n        for (i = 0; i < 12; i++) {\r\n            // make the regex if we don't have it already\r\n            mom = createUTC([2000, i]);\r\n            if (strict && !this._longMonthsParse[i]) {\r\n                this._longMonthsParse[i] = new RegExp(\r\n                    '^' + this.months(mom, '').replace('.', '') + '$',\r\n                    'i'\r\n                );\r\n                this._shortMonthsParse[i] = new RegExp(\r\n                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',\r\n                    'i'\r\n                );\r\n            }\r\n            if (!strict && !this._monthsParse[i]) {\r\n                regex =\r\n                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\r\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\r\n            }\r\n            // test the regex\r\n            if (\r\n                strict &&\r\n                format === 'MMMM' &&\r\n                this._longMonthsParse[i].test(monthName)\r\n            ) {\r\n                return i;\r\n            } else if (\r\n                strict &&\r\n                format === 'MMM' &&\r\n                this._shortMonthsParse[i].test(monthName)\r\n            ) {\r\n                return i;\r\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function setMonth(mom, value) {\r\n        var dayOfMonth;\r\n\r\n        if (!mom.isValid()) {\r\n            // No op\r\n            return mom;\r\n        }\r\n\r\n        if (typeof value === 'string') {\r\n            if (/^\\d+$/.test(value)) {\r\n                value = toInt(value);\r\n            } else {\r\n                value = mom.localeData().monthsParse(value);\r\n                // TODO: Another silent failure?\r\n                if (!isNumber(value)) {\r\n                    return mom;\r\n                }\r\n            }\r\n        }\r\n\r\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\r\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\r\n        return mom;\r\n    }\r\n\r\n    function getSetMonth(value) {\r\n        if (value != null) {\r\n            setMonth(this, value);\r\n            hooks.updateOffset(this, true);\r\n            return this;\r\n        } else {\r\n            return get(this, 'Month');\r\n        }\r\n    }\r\n\r\n    function getDaysInMonth() {\r\n        return daysInMonth(this.year(), this.month());\r\n    }\r\n\r\n    function monthsShortRegex(isStrict) {\r\n        if (this._monthsParseExact) {\r\n            if (!hasOwnProp(this, '_monthsRegex')) {\r\n                computeMonthsParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._monthsShortStrictRegex;\r\n            } else {\r\n                return this._monthsShortRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\r\n                this._monthsShortRegex = defaultMonthsShortRegex;\r\n            }\r\n            return this._monthsShortStrictRegex && isStrict\r\n                ? this._monthsShortStrictRegex\r\n                : this._monthsShortRegex;\r\n        }\r\n    }\r\n\r\n    function monthsRegex(isStrict) {\r\n        if (this._monthsParseExact) {\r\n            if (!hasOwnProp(this, '_monthsRegex')) {\r\n                computeMonthsParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._monthsStrictRegex;\r\n            } else {\r\n                return this._monthsRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_monthsRegex')) {\r\n                this._monthsRegex = defaultMonthsRegex;\r\n            }\r\n            return this._monthsStrictRegex && isStrict\r\n                ? this._monthsStrictRegex\r\n                : this._monthsRegex;\r\n        }\r\n    }\r\n\r\n    function computeMonthsParse() {\r\n        function cmpLenRev(a, b) {\r\n            return b.length - a.length;\r\n        }\r\n\r\n        var shortPieces = [],\r\n            longPieces = [],\r\n            mixedPieces = [],\r\n            i,\r\n            mom;\r\n        for (i = 0; i < 12; i++) {\r\n            // make the regex if we don't have it already\r\n            mom = createUTC([2000, i]);\r\n            shortPieces.push(this.monthsShort(mom, ''));\r\n            longPieces.push(this.months(mom, ''));\r\n            mixedPieces.push(this.months(mom, ''));\r\n            mixedPieces.push(this.monthsShort(mom, ''));\r\n        }\r\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\r\n        // will match the longer piece.\r\n        shortPieces.sort(cmpLenRev);\r\n        longPieces.sort(cmpLenRev);\r\n        mixedPieces.sort(cmpLenRev);\r\n        for (i = 0; i < 12; i++) {\r\n            shortPieces[i] = regexEscape(shortPieces[i]);\r\n            longPieces[i] = regexEscape(longPieces[i]);\r\n        }\r\n        for (i = 0; i < 24; i++) {\r\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\r\n        }\r\n\r\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\r\n        this._monthsShortRegex = this._monthsRegex;\r\n        this._monthsStrictRegex = new RegExp(\r\n            '^(' + longPieces.join('|') + ')',\r\n            'i'\r\n        );\r\n        this._monthsShortStrictRegex = new RegExp(\r\n            '^(' + shortPieces.join('|') + ')',\r\n            'i'\r\n        );\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('Y', 0, 0, function () {\r\n        var y = this.year();\r\n        return y <= 9999 ? zeroFill(y, 4) : '+' + y;\r\n    });\r\n\r\n    addFormatToken(0, ['YY', 2], 0, function () {\r\n        return this.year() % 100;\r\n    });\r\n\r\n    addFormatToken(0, ['YYYY', 4], 0, 'year');\r\n    addFormatToken(0, ['YYYYY', 5], 0, 'year');\r\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('year', 'y');\r\n\r\n    // PRIORITIES\r\n\r\n    addUnitPriority('year', 1);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('Y', matchSigned);\r\n    addRegexToken('YY', match1to2, match2);\r\n    addRegexToken('YYYY', match1to4, match4);\r\n    addRegexToken('YYYYY', match1to6, match6);\r\n    addRegexToken('YYYYYY', match1to6, match6);\r\n\r\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\r\n    addParseToken('YYYY', function (input, array) {\r\n        array[YEAR] =\r\n            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\r\n    });\r\n    addParseToken('YY', function (input, array) {\r\n        array[YEAR] = hooks.parseTwoDigitYear(input);\r\n    });\r\n    addParseToken('Y', function (input, array) {\r\n        array[YEAR] = parseInt(input, 10);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    function daysInYear(year) {\r\n        return isLeapYear(year) ? 366 : 365;\r\n    }\r\n\r\n    // HOOKS\r\n\r\n    hooks.parseTwoDigitYear = function (input) {\r\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\r\n    };\r\n\r\n    // MOMENTS\r\n\r\n    var getSetYear = makeGetSet('FullYear', true);\r\n\r\n    function getIsLeapYear() {\r\n        return isLeapYear(this.year());\r\n    }\r\n\r\n    function createDate(y, m, d, h, M, s, ms) {\r\n        // can't just apply() to create a date:\r\n        // https://stackoverflow.com/q/181348\r\n        var date;\r\n        // the date constructor remaps years 0-99 to 1900-1999\r\n        if (y < 100 && y >= 0) {\r\n            // preserve leap years using a full 400 year cycle, then reset\r\n            date = new Date(y + 400, m, d, h, M, s, ms);\r\n            if (isFinite(date.getFullYear())) {\r\n                date.setFullYear(y);\r\n            }\r\n        } else {\r\n            date = new Date(y, m, d, h, M, s, ms);\r\n        }\r\n\r\n        return date;\r\n    }\r\n\r\n    function createUTCDate(y) {\r\n        var date, args;\r\n        // the Date.UTC function remaps years 0-99 to 1900-1999\r\n        if (y < 100 && y >= 0) {\r\n            args = Array.prototype.slice.call(arguments);\r\n            // preserve leap years using a full 400 year cycle, then reset\r\n            args[0] = y + 400;\r\n            date = new Date(Date.UTC.apply(null, args));\r\n            if (isFinite(date.getUTCFullYear())) {\r\n                date.setUTCFullYear(y);\r\n            }\r\n        } else {\r\n            date = new Date(Date.UTC.apply(null, arguments));\r\n        }\r\n\r\n        return date;\r\n    }\r\n\r\n    // start-of-first-week - start-of-year\r\n    function firstWeekOffset(year, dow, doy) {\r\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\r\n            fwd = 7 + dow - doy,\r\n            // first-week day local weekday -- which local weekday is fwd\r\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\r\n\r\n        return -fwdlw + fwd - 1;\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\r\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\r\n        var localWeekday = (7 + weekday - dow) % 7,\r\n            weekOffset = firstWeekOffset(year, dow, doy),\r\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\r\n            resYear,\r\n            resDayOfYear;\r\n\r\n        if (dayOfYear <= 0) {\r\n            resYear = year - 1;\r\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\r\n        } else if (dayOfYear > daysInYear(year)) {\r\n            resYear = year + 1;\r\n            resDayOfYear = dayOfYear - daysInYear(year);\r\n        } else {\r\n            resYear = year;\r\n            resDayOfYear = dayOfYear;\r\n        }\r\n\r\n        return {\r\n            year: resYear,\r\n            dayOfYear: resDayOfYear,\r\n        };\r\n    }\r\n\r\n    function weekOfYear(mom, dow, doy) {\r\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\r\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\r\n            resWeek,\r\n            resYear;\r\n\r\n        if (week < 1) {\r\n            resYear = mom.year() - 1;\r\n            resWeek = week + weeksInYear(resYear, dow, doy);\r\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\r\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\r\n            resYear = mom.year() + 1;\r\n        } else {\r\n            resYear = mom.year();\r\n            resWeek = week;\r\n        }\r\n\r\n        return {\r\n            week: resWeek,\r\n            year: resYear,\r\n        };\r\n    }\r\n\r\n    function weeksInYear(year, dow, doy) {\r\n        var weekOffset = firstWeekOffset(year, dow, doy),\r\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\r\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\r\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('week', 'w');\r\n    addUnitAlias('isoWeek', 'W');\r\n\r\n    // PRIORITIES\r\n\r\n    addUnitPriority('week', 5);\r\n    addUnitPriority('isoWeek', 5);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('w', match1to2);\r\n    addRegexToken('ww', match1to2, match2);\r\n    addRegexToken('W', match1to2);\r\n    addRegexToken('WW', match1to2, match2);\r\n\r\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (\r\n        input,\r\n        week,\r\n        config,\r\n        token\r\n    ) {\r\n        week[token.substr(0, 1)] = toInt(input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    // LOCALES\r\n\r\n    function localeWeek(mom) {\r\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\r\n    }\r\n\r\n    var defaultLocaleWeek = {\r\n        dow: 0, // Sunday is the first day of the week.\r\n        doy: 6, // The week that contains Jan 6th is the first week of the year.\r\n    };\r\n\r\n    function localeFirstDayOfWeek() {\r\n        return this._week.dow;\r\n    }\r\n\r\n    function localeFirstDayOfYear() {\r\n        return this._week.doy;\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function getSetWeek(input) {\r\n        var week = this.localeData().week(this);\r\n        return input == null ? week : this.add((input - week) * 7, 'd');\r\n    }\r\n\r\n    function getSetISOWeek(input) {\r\n        var week = weekOfYear(this, 1, 4).week;\r\n        return input == null ? week : this.add((input - week) * 7, 'd');\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('d', 0, 'do', 'day');\r\n\r\n    addFormatToken('dd', 0, 0, function (format) {\r\n        return this.localeData().weekdaysMin(this, format);\r\n    });\r\n\r\n    addFormatToken('ddd', 0, 0, function (format) {\r\n        return this.localeData().weekdaysShort(this, format);\r\n    });\r\n\r\n    addFormatToken('dddd', 0, 0, function (format) {\r\n        return this.localeData().weekdays(this, format);\r\n    });\r\n\r\n    addFormatToken('e', 0, 0, 'weekday');\r\n    addFormatToken('E', 0, 0, 'isoWeekday');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('day', 'd');\r\n    addUnitAlias('weekday', 'e');\r\n    addUnitAlias('isoWeekday', 'E');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('day', 11);\r\n    addUnitPriority('weekday', 11);\r\n    addUnitPriority('isoWeekday', 11);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('d', match1to2);\r\n    addRegexToken('e', match1to2);\r\n    addRegexToken('E', match1to2);\r\n    addRegexToken('dd', function (isStrict, locale) {\r\n        return locale.weekdaysMinRegex(isStrict);\r\n    });\r\n    addRegexToken('ddd', function (isStrict, locale) {\r\n        return locale.weekdaysShortRegex(isStrict);\r\n    });\r\n    addRegexToken('dddd', function (isStrict, locale) {\r\n        return locale.weekdaysRegex(isStrict);\r\n    });\r\n\r\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\r\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\r\n        // if we didn't get a weekday name, mark the date as invalid\r\n        if (weekday != null) {\r\n            week.d = weekday;\r\n        } else {\r\n            getParsingFlags(config).invalidWeekday = input;\r\n        }\r\n    });\r\n\r\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\r\n        week[token] = toInt(input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    function parseWeekday(input, locale) {\r\n        if (typeof input !== 'string') {\r\n            return input;\r\n        }\r\n\r\n        if (!isNaN(input)) {\r\n            return parseInt(input, 10);\r\n        }\r\n\r\n        input = locale.weekdaysParse(input);\r\n        if (typeof input === 'number') {\r\n            return input;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function parseIsoWeekday(input, locale) {\r\n        if (typeof input === 'string') {\r\n            return locale.weekdaysParse(input) % 7 || 7;\r\n        }\r\n        return isNaN(input) ? null : input;\r\n    }\r\n\r\n    // LOCALES\r\n    function shiftWeekdays(ws, n) {\r\n        return ws.slice(n, 7).concat(ws.slice(0, n));\r\n    }\r\n\r\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(\r\n            '_'\r\n        ),\r\n        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\r\n        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\r\n        defaultWeekdaysRegex = matchWord,\r\n        defaultWeekdaysShortRegex = matchWord,\r\n        defaultWeekdaysMinRegex = matchWord;\r\n\r\n    function localeWeekdays(m, format) {\r\n        var weekdays = isArray(this._weekdays)\r\n            ? this._weekdays\r\n            : this._weekdays[\r\n                  m && m !== true && this._weekdays.isFormat.test(format)\r\n                      ? 'format'\r\n                      : 'standalone'\r\n              ];\r\n        return m === true\r\n            ? shiftWeekdays(weekdays, this._week.dow)\r\n            : m\r\n            ? weekdays[m.day()]\r\n            : weekdays;\r\n    }\r\n\r\n    function localeWeekdaysShort(m) {\r\n        return m === true\r\n            ? shiftWeekdays(this._weekdaysShort, this._week.dow)\r\n            : m\r\n            ? this._weekdaysShort[m.day()]\r\n            : this._weekdaysShort;\r\n    }\r\n\r\n    function localeWeekdaysMin(m) {\r\n        return m === true\r\n            ? shiftWeekdays(this._weekdaysMin, this._week.dow)\r\n            : m\r\n            ? this._weekdaysMin[m.day()]\r\n            : this._weekdaysMin;\r\n    }\r\n\r\n    function handleStrictParse$1(weekdayName, format, strict) {\r\n        var i,\r\n            ii,\r\n            mom,\r\n            llc = weekdayName.toLocaleLowerCase();\r\n        if (!this._weekdaysParse) {\r\n            this._weekdaysParse = [];\r\n            this._shortWeekdaysParse = [];\r\n            this._minWeekdaysParse = [];\r\n\r\n            for (i = 0; i < 7; ++i) {\r\n                mom = createUTC([2000, 1]).day(i);\r\n                this._minWeekdaysParse[i] = this.weekdaysMin(\r\n                    mom,\r\n                    ''\r\n                ).toLocaleLowerCase();\r\n                this._shortWeekdaysParse[i] = this.weekdaysShort(\r\n                    mom,\r\n                    ''\r\n                ).toLocaleLowerCase();\r\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\r\n            }\r\n        }\r\n\r\n        if (strict) {\r\n            if (format === 'dddd') {\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else if (format === 'ddd') {\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        } else {\r\n            if (format === 'dddd') {\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else if (format === 'ddd') {\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            } else {\r\n                ii = indexOf.call(this._minWeekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._weekdaysParse, llc);\r\n                if (ii !== -1) {\r\n                    return ii;\r\n                }\r\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\r\n                return ii !== -1 ? ii : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    function localeWeekdaysParse(weekdayName, format, strict) {\r\n        var i, mom, regex;\r\n\r\n        if (this._weekdaysParseExact) {\r\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\r\n        }\r\n\r\n        if (!this._weekdaysParse) {\r\n            this._weekdaysParse = [];\r\n            this._minWeekdaysParse = [];\r\n            this._shortWeekdaysParse = [];\r\n            this._fullWeekdaysParse = [];\r\n        }\r\n\r\n        for (i = 0; i < 7; i++) {\r\n            // make the regex if we don't have it already\r\n\r\n            mom = createUTC([2000, 1]).day(i);\r\n            if (strict && !this._fullWeekdaysParse[i]) {\r\n                this._fullWeekdaysParse[i] = new RegExp(\r\n                    '^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$',\r\n                    'i'\r\n                );\r\n                this._shortWeekdaysParse[i] = new RegExp(\r\n                    '^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$',\r\n                    'i'\r\n                );\r\n                this._minWeekdaysParse[i] = new RegExp(\r\n                    '^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$',\r\n                    'i'\r\n                );\r\n            }\r\n            if (!this._weekdaysParse[i]) {\r\n                regex =\r\n                    '^' +\r\n                    this.weekdays(mom, '') +\r\n                    '|^' +\r\n                    this.weekdaysShort(mom, '') +\r\n                    '|^' +\r\n                    this.weekdaysMin(mom, '');\r\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\r\n            }\r\n            // test the regex\r\n            if (\r\n                strict &&\r\n                format === 'dddd' &&\r\n                this._fullWeekdaysParse[i].test(weekdayName)\r\n            ) {\r\n                return i;\r\n            } else if (\r\n                strict &&\r\n                format === 'ddd' &&\r\n                this._shortWeekdaysParse[i].test(weekdayName)\r\n            ) {\r\n                return i;\r\n            } else if (\r\n                strict &&\r\n                format === 'dd' &&\r\n                this._minWeekdaysParse[i].test(weekdayName)\r\n            ) {\r\n                return i;\r\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // MOMENTS\r\n\r\n    function getSetDayOfWeek(input) {\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\r\n        if (input != null) {\r\n            input = parseWeekday(input, this.localeData());\r\n            return this.add(input - day, 'd');\r\n        } else {\r\n            return day;\r\n        }\r\n    }\r\n\r\n    function getSetLocaleDayOfWeek(input) {\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\r\n        return input == null ? weekday : this.add(input - weekday, 'd');\r\n    }\r\n\r\n    function getSetISODayOfWeek(input) {\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n\r\n        // behaves the same as moment#day except\r\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\r\n        // as a setter, sunday should belong to the previous week.\r\n\r\n        if (input != null) {\r\n            var weekday = parseIsoWeekday(input, this.localeData());\r\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\r\n        } else {\r\n            return this.day() || 7;\r\n        }\r\n    }\r\n\r\n    function weekdaysRegex(isStrict) {\r\n        if (this._weekdaysParseExact) {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                computeWeekdaysParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._weekdaysStrictRegex;\r\n            } else {\r\n                return this._weekdaysRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                this._weekdaysRegex = defaultWeekdaysRegex;\r\n            }\r\n            return this._weekdaysStrictRegex && isStrict\r\n                ? this._weekdaysStrictRegex\r\n                : this._weekdaysRegex;\r\n        }\r\n    }\r\n\r\n    function weekdaysShortRegex(isStrict) {\r\n        if (this._weekdaysParseExact) {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                computeWeekdaysParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._weekdaysShortStrictRegex;\r\n            } else {\r\n                return this._weekdaysShortRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\r\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\r\n            }\r\n            return this._weekdaysShortStrictRegex && isStrict\r\n                ? this._weekdaysShortStrictRegex\r\n                : this._weekdaysShortRegex;\r\n        }\r\n    }\r\n\r\n    function weekdaysMinRegex(isStrict) {\r\n        if (this._weekdaysParseExact) {\r\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\r\n                computeWeekdaysParse.call(this);\r\n            }\r\n            if (isStrict) {\r\n                return this._weekdaysMinStrictRegex;\r\n            } else {\r\n                return this._weekdaysMinRegex;\r\n            }\r\n        } else {\r\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\r\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\r\n            }\r\n            return this._weekdaysMinStrictRegex && isStrict\r\n                ? this._weekdaysMinStrictRegex\r\n                : this._weekdaysMinRegex;\r\n        }\r\n    }\r\n\r\n    function computeWeekdaysParse() {\r\n        function cmpLenRev(a, b) {\r\n            return b.length - a.length;\r\n        }\r\n\r\n        var minPieces = [],\r\n            shortPieces = [],\r\n            longPieces = [],\r\n            mixedPieces = [],\r\n            i,\r\n            mom,\r\n            minp,\r\n            shortp,\r\n            longp;\r\n        for (i = 0; i < 7; i++) {\r\n            // make the regex if we don't have it already\r\n            mom = createUTC([2000, 1]).day(i);\r\n            minp = regexEscape(this.weekdaysMin(mom, ''));\r\n            shortp = regexEscape(this.weekdaysShort(mom, ''));\r\n            longp = regexEscape(this.weekdays(mom, ''));\r\n            minPieces.push(minp);\r\n            shortPieces.push(shortp);\r\n            longPieces.push(longp);\r\n            mixedPieces.push(minp);\r\n            mixedPieces.push(shortp);\r\n            mixedPieces.push(longp);\r\n        }\r\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\r\n        // will match the longer piece.\r\n        minPieces.sort(cmpLenRev);\r\n        shortPieces.sort(cmpLenRev);\r\n        longPieces.sort(cmpLenRev);\r\n        mixedPieces.sort(cmpLenRev);\r\n\r\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\r\n        this._weekdaysShortRegex = this._weekdaysRegex;\r\n        this._weekdaysMinRegex = this._weekdaysRegex;\r\n\r\n        this._weekdaysStrictRegex = new RegExp(\r\n            '^(' + longPieces.join('|') + ')',\r\n            'i'\r\n        );\r\n        this._weekdaysShortStrictRegex = new RegExp(\r\n            '^(' + shortPieces.join('|') + ')',\r\n            'i'\r\n        );\r\n        this._weekdaysMinStrictRegex = new RegExp(\r\n            '^(' + minPieces.join('|') + ')',\r\n            'i'\r\n        );\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    function hFormat() {\r\n        return this.hours() % 12 || 12;\r\n    }\r\n\r\n    function kFormat() {\r\n        return this.hours() || 24;\r\n    }\r\n\r\n    addFormatToken('H', ['HH', 2], 0, 'hour');\r\n    addFormatToken('h', ['hh', 2], 0, hFormat);\r\n    addFormatToken('k', ['kk', 2], 0, kFormat);\r\n\r\n    addFormatToken('hmm', 0, 0, function () {\r\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\r\n    });\r\n\r\n    addFormatToken('hmmss', 0, 0, function () {\r\n        return (\r\n            '' +\r\n            hFormat.apply(this) +\r\n            zeroFill(this.minutes(), 2) +\r\n            zeroFill(this.seconds(), 2)\r\n        );\r\n    });\r\n\r\n    addFormatToken('Hmm', 0, 0, function () {\r\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\r\n    });\r\n\r\n    addFormatToken('Hmmss', 0, 0, function () {\r\n        return (\r\n            '' +\r\n            this.hours() +\r\n            zeroFill(this.minutes(), 2) +\r\n            zeroFill(this.seconds(), 2)\r\n        );\r\n    });\r\n\r\n    function meridiem(token, lowercase) {\r\n        addFormatToken(token, 0, 0, function () {\r\n            return this.localeData().meridiem(\r\n                this.hours(),\r\n                this.minutes(),\r\n                lowercase\r\n            );\r\n        });\r\n    }\r\n\r\n    meridiem('a', true);\r\n    meridiem('A', false);\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('hour', 'h');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('hour', 13);\r\n\r\n    // PARSING\r\n\r\n    function matchMeridiem(isStrict, locale) {\r\n        return locale._meridiemParse;\r\n    }\r\n\r\n    addRegexToken('a', matchMeridiem);\r\n    addRegexToken('A', matchMeridiem);\r\n    addRegexToken('H', match1to2);\r\n    addRegexToken('h', match1to2);\r\n    addRegexToken('k', match1to2);\r\n    addRegexToken('HH', match1to2, match2);\r\n    addRegexToken('hh', match1to2, match2);\r\n    addRegexToken('kk', match1to2, match2);\r\n\r\n    addRegexToken('hmm', match3to4);\r\n    addRegexToken('hmmss', match5to6);\r\n    addRegexToken('Hmm', match3to4);\r\n    addRegexToken('Hmmss', match5to6);\r\n\r\n    addParseToken(['H', 'HH'], HOUR);\r\n    addParseToken(['k', 'kk'], function (input, array, config) {\r\n        var kInput = toInt(input);\r\n        array[HOUR] = kInput === 24 ? 0 : kInput;\r\n    });\r\n    addParseToken(['a', 'A'], function (input, array, config) {\r\n        config._isPm = config._locale.isPM(input);\r\n        config._meridiem = input;\r\n    });\r\n    addParseToken(['h', 'hh'], function (input, array, config) {\r\n        array[HOUR] = toInt(input);\r\n        getParsingFlags(config).bigHour = true;\r\n    });\r\n    addParseToken('hmm', function (input, array, config) {\r\n        var pos = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos));\r\n        array[MINUTE] = toInt(input.substr(pos));\r\n        getParsingFlags(config).bigHour = true;\r\n    });\r\n    addParseToken('hmmss', function (input, array, config) {\r\n        var pos1 = input.length - 4,\r\n            pos2 = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos1));\r\n        array[MINUTE] = toInt(input.substr(pos1, 2));\r\n        array[SECOND] = toInt(input.substr(pos2));\r\n        getParsingFlags(config).bigHour = true;\r\n    });\r\n    addParseToken('Hmm', function (input, array, config) {\r\n        var pos = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos));\r\n        array[MINUTE] = toInt(input.substr(pos));\r\n    });\r\n    addParseToken('Hmmss', function (input, array, config) {\r\n        var pos1 = input.length - 4,\r\n            pos2 = input.length - 2;\r\n        array[HOUR] = toInt(input.substr(0, pos1));\r\n        array[MINUTE] = toInt(input.substr(pos1, 2));\r\n        array[SECOND] = toInt(input.substr(pos2));\r\n    });\r\n\r\n    // LOCALES\r\n\r\n    function localeIsPM(input) {\r\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\r\n        // Using charAt should be more compatible.\r\n        return (input + '').toLowerCase().charAt(0) === 'p';\r\n    }\r\n\r\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\r\n        // Setting the hour should keep the time, because the user explicitly\r\n        // specified which hour they want. So trying to maintain the same hour (in\r\n        // a new timezone) makes sense. Adding/subtracting hours does not follow\r\n        // this rule.\r\n        getSetHour = makeGetSet('Hours', true);\r\n\r\n    function localeMeridiem(hours, minutes, isLower) {\r\n        if (hours > 11) {\r\n            return isLower ? 'pm' : 'PM';\r\n        } else {\r\n            return isLower ? 'am' : 'AM';\r\n        }\r\n    }\r\n\r\n    var baseConfig = {\r\n        calendar: defaultCalendar,\r\n        longDateFormat: defaultLongDateFormat,\r\n        invalidDate: defaultInvalidDate,\r\n        ordinal: defaultOrdinal,\r\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\r\n        relativeTime: defaultRelativeTime,\r\n\r\n        months: defaultLocaleMonths,\r\n        monthsShort: defaultLocaleMonthsShort,\r\n\r\n        week: defaultLocaleWeek,\r\n\r\n        weekdays: defaultLocaleWeekdays,\r\n        weekdaysMin: defaultLocaleWeekdaysMin,\r\n        weekdaysShort: defaultLocaleWeekdaysShort,\r\n\r\n        meridiemParse: defaultLocaleMeridiemParse,\r\n    };\r\n\r\n    // internal storage for locale config files\r\n    var locales = {},\r\n        localeFamilies = {},\r\n        globalLocale;\r\n\r\n    function commonPrefix(arr1, arr2) {\r\n        var i,\r\n            minl = Math.min(arr1.length, arr2.length);\r\n        for (i = 0; i < minl; i += 1) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return minl;\r\n    }\r\n\r\n    function normalizeLocale(key) {\r\n        return key ? key.toLowerCase().replace('_', '-') : key;\r\n    }\r\n\r\n    // pick the locale from the array\r\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\r\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\r\n    function chooseLocale(names) {\r\n        var i = 0,\r\n            j,\r\n            next,\r\n            locale,\r\n            split;\r\n\r\n        while (i < names.length) {\r\n            split = normalizeLocale(names[i]).split('-');\r\n            j = split.length;\r\n            next = normalizeLocale(names[i + 1]);\r\n            next = next ? next.split('-') : null;\r\n            while (j > 0) {\r\n                locale = loadLocale(split.slice(0, j).join('-'));\r\n                if (locale) {\r\n                    return locale;\r\n                }\r\n                if (\r\n                    next &&\r\n                    next.length >= j &&\r\n                    commonPrefix(split, next) >= j - 1\r\n                ) {\r\n                    //the next array item is better than a shallower substring of this one\r\n                    break;\r\n                }\r\n                j--;\r\n            }\r\n            i++;\r\n        }\r\n        return globalLocale;\r\n    }\r\n\r\n    function loadLocale(name) {\r\n        var oldLocale = null,\r\n            aliasedRequire;\r\n        // TODO: Find a better way to register and load all the locales in Node\r\n        if (\r\n            locales[name] === undefined &&\r\n            typeof module !== 'undefined' &&\r\n            module &&\r\n            module.exports\r\n        ) {\r\n            try {\r\n                oldLocale = globalLocale._abbr;\r\n                aliasedRequire = require;\r\n                aliasedRequire('./locale/' + name);\r\n                getSetGlobalLocale(oldLocale);\r\n            } catch (e) {\r\n                // mark as not found to avoid repeating expensive file require call causing high CPU\r\n                // when trying to find en-US, en_US, en-us for every format call\r\n                locales[name] = null; // null means not found\r\n            }\r\n        }\r\n        return locales[name];\r\n    }\r\n\r\n    // This function will load locale and then set the global locale.  If\r\n    // no arguments are passed in, it will simply return the current global\r\n    // locale key.\r\n    function getSetGlobalLocale(key, values) {\r\n        var data;\r\n        if (key) {\r\n            if (isUndefined(values)) {\r\n                data = getLocale(key);\r\n            } else {\r\n                data = defineLocale(key, values);\r\n            }\r\n\r\n            if (data) {\r\n                // moment.duration._locale = moment._locale = data;\r\n                globalLocale = data;\r\n            } else {\r\n                if (typeof console !== 'undefined' && console.warn) {\r\n                    //warn user if arguments are passed but the locale could not be set\r\n                    console.warn(\r\n                        'Locale ' + key + ' not found. Did you forget to load it?'\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return globalLocale._abbr;\r\n    }\r\n\r\n    function defineLocale(name, config) {\r\n        if (config !== null) {\r\n            var locale,\r\n                parentConfig = baseConfig;\r\n            config.abbr = name;\r\n            if (locales[name] != null) {\r\n                deprecateSimple(\r\n                    'defineLocaleOverride',\r\n                    'use moment.updateLocale(localeName, config) to change ' +\r\n                        'an existing locale. moment.defineLocale(localeName, ' +\r\n                        'config) should only be used for creating a new locale ' +\r\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'\r\n                );\r\n                parentConfig = locales[name]._config;\r\n            } else if (config.parentLocale != null) {\r\n                if (locales[config.parentLocale] != null) {\r\n                    parentConfig = locales[config.parentLocale]._config;\r\n                } else {\r\n                    locale = loadLocale(config.parentLocale);\r\n                    if (locale != null) {\r\n                        parentConfig = locale._config;\r\n                    } else {\r\n                        if (!localeFamilies[config.parentLocale]) {\r\n                            localeFamilies[config.parentLocale] = [];\r\n                        }\r\n                        localeFamilies[config.parentLocale].push({\r\n                            name: name,\r\n                            config: config,\r\n                        });\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\r\n\r\n            if (localeFamilies[name]) {\r\n                localeFamilies[name].forEach(function (x) {\r\n                    defineLocale(x.name, x.config);\r\n                });\r\n            }\r\n\r\n            // backwards compat for now: also set the locale\r\n            // make sure we set the locale AFTER all child locales have been\r\n            // created, so we won't end up with the child locale set.\r\n            getSetGlobalLocale(name);\r\n\r\n            return locales[name];\r\n        } else {\r\n            // useful for testing\r\n            delete locales[name];\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function updateLocale(name, config) {\r\n        if (config != null) {\r\n            var locale,\r\n                tmpLocale,\r\n                parentConfig = baseConfig;\r\n\r\n            if (locales[name] != null && locales[name].parentLocale != null) {\r\n                // Update existing child locale in-place to avoid memory-leaks\r\n                locales[name].set(mergeConfigs(locales[name]._config, config));\r\n            } else {\r\n                // MERGE\r\n                tmpLocale = loadLocale(name);\r\n                if (tmpLocale != null) {\r\n                    parentConfig = tmpLocale._config;\r\n                }\r\n                config = mergeConfigs(parentConfig, config);\r\n                if (tmpLocale == null) {\r\n                    // updateLocale is called for creating a new locale\r\n                    // Set abbr so it will have a name (getters return\r\n                    // undefined otherwise).\r\n                    config.abbr = name;\r\n                }\r\n                locale = new Locale(config);\r\n                locale.parentLocale = locales[name];\r\n                locales[name] = locale;\r\n            }\r\n\r\n            // backwards compat for now: also set the locale\r\n            getSetGlobalLocale(name);\r\n        } else {\r\n            // pass null for config to unupdate, useful for tests\r\n            if (locales[name] != null) {\r\n                if (locales[name].parentLocale != null) {\r\n                    locales[name] = locales[name].parentLocale;\r\n                    if (name === getSetGlobalLocale()) {\r\n                        getSetGlobalLocale(name);\r\n                    }\r\n                } else if (locales[name] != null) {\r\n                    delete locales[name];\r\n                }\r\n            }\r\n        }\r\n        return locales[name];\r\n    }\r\n\r\n    // returns locale data\r\n    function getLocale(key) {\r\n        var locale;\r\n\r\n        if (key && key._locale && key._locale._abbr) {\r\n            key = key._locale._abbr;\r\n        }\r\n\r\n        if (!key) {\r\n            return globalLocale;\r\n        }\r\n\r\n        if (!isArray(key)) {\r\n            //short-circuit everything else\r\n            locale = loadLocale(key);\r\n            if (locale) {\r\n                return locale;\r\n            }\r\n            key = [key];\r\n        }\r\n\r\n        return chooseLocale(key);\r\n    }\r\n\r\n    function listLocales() {\r\n        return keys(locales);\r\n    }\r\n\r\n    function checkOverflow(m) {\r\n        var overflow,\r\n            a = m._a;\r\n\r\n        if (a && getParsingFlags(m).overflow === -2) {\r\n            overflow =\r\n                a[MONTH] < 0 || a[MONTH] > 11\r\n                    ? MONTH\r\n                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])\r\n                    ? DATE\r\n                    : a[HOUR] < 0 ||\r\n                      a[HOUR] > 24 ||\r\n                      (a[HOUR] === 24 &&\r\n                          (a[MINUTE] !== 0 ||\r\n                              a[SECOND] !== 0 ||\r\n                              a[MILLISECOND] !== 0))\r\n                    ? HOUR\r\n                    : a[MINUTE] < 0 || a[MINUTE] > 59\r\n                    ? MINUTE\r\n                    : a[SECOND] < 0 || a[SECOND] > 59\r\n                    ? SECOND\r\n                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999\r\n                    ? MILLISECOND\r\n                    : -1;\r\n\r\n            if (\r\n                getParsingFlags(m)._overflowDayOfYear &&\r\n                (overflow < YEAR || overflow > DATE)\r\n            ) {\r\n                overflow = DATE;\r\n            }\r\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\r\n                overflow = WEEK;\r\n            }\r\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\r\n                overflow = WEEKDAY;\r\n            }\r\n\r\n            getParsingFlags(m).overflow = overflow;\r\n        }\r\n\r\n        return m;\r\n    }\r\n\r\n    // iso 8601 regex\r\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\r\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\r\n        basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\r\n        tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\r\n        isoDates = [\r\n            ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\r\n            ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\r\n            ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\r\n            ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\r\n            ['YYYY-DDD', /\\d{4}-\\d{3}/],\r\n            ['YYYY-MM', /\\d{4}-\\d\\d/, false],\r\n            ['YYYYYYMMDD', /[+-]\\d{10}/],\r\n            ['YYYYMMDD', /\\d{8}/],\r\n            ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\r\n            ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\r\n            ['YYYYDDD', /\\d{7}/],\r\n            ['YYYYMM', /\\d{6}/, false],\r\n            ['YYYY', /\\d{4}/, false],\r\n        ],\r\n        // iso time formats and regexes\r\n        isoTimes = [\r\n            ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\r\n            ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\r\n            ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\r\n            ['HH:mm', /\\d\\d:\\d\\d/],\r\n            ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\r\n            ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\r\n            ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\r\n            ['HHmm', /\\d\\d\\d\\d/],\r\n            ['HH', /\\d\\d/],\r\n        ],\r\n        aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\r\n        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\r\n        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\r\n        obsOffsets = {\r\n            UT: 0,\r\n            GMT: 0,\r\n            EDT: -4 * 60,\r\n            EST: -5 * 60,\r\n            CDT: -5 * 60,\r\n            CST: -6 * 60,\r\n            MDT: -6 * 60,\r\n            MST: -7 * 60,\r\n            PDT: -7 * 60,\r\n            PST: -8 * 60,\r\n        };\r\n\r\n    // date from iso format\r\n    function configFromISO(config) {\r\n        var i,\r\n            l,\r\n            string = config._i,\r\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\r\n            allowTime,\r\n            dateFormat,\r\n            timeFormat,\r\n            tzFormat;\r\n\r\n        if (match) {\r\n            getParsingFlags(config).iso = true;\r\n\r\n            for (i = 0, l = isoDates.length; i < l; i++) {\r\n                if (isoDates[i][1].exec(match[1])) {\r\n                    dateFormat = isoDates[i][0];\r\n                    allowTime = isoDates[i][2] !== false;\r\n                    break;\r\n                }\r\n            }\r\n            if (dateFormat == null) {\r\n                config._isValid = false;\r\n                return;\r\n            }\r\n            if (match[3]) {\r\n                for (i = 0, l = isoTimes.length; i < l; i++) {\r\n                    if (isoTimes[i][1].exec(match[3])) {\r\n                        // match[2] should be 'T' or space\r\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\r\n                        break;\r\n                    }\r\n                }\r\n                if (timeFormat == null) {\r\n                    config._isValid = false;\r\n                    return;\r\n                }\r\n            }\r\n            if (!allowTime && timeFormat != null) {\r\n                config._isValid = false;\r\n                return;\r\n            }\r\n            if (match[4]) {\r\n                if (tzRegex.exec(match[4])) {\r\n                    tzFormat = 'Z';\r\n                } else {\r\n                    config._isValid = false;\r\n                    return;\r\n                }\r\n            }\r\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\r\n            configFromStringAndFormat(config);\r\n        } else {\r\n            config._isValid = false;\r\n        }\r\n    }\r\n\r\n    function extractFromRFC2822Strings(\r\n        yearStr,\r\n        monthStr,\r\n        dayStr,\r\n        hourStr,\r\n        minuteStr,\r\n        secondStr\r\n    ) {\r\n        var result = [\r\n            untruncateYear(yearStr),\r\n            defaultLocaleMonthsShort.indexOf(monthStr),\r\n            parseInt(dayStr, 10),\r\n            parseInt(hourStr, 10),\r\n            parseInt(minuteStr, 10),\r\n        ];\r\n\r\n        if (secondStr) {\r\n            result.push(parseInt(secondStr, 10));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function untruncateYear(yearStr) {\r\n        var year = parseInt(yearStr, 10);\r\n        if (year <= 49) {\r\n            return 2000 + year;\r\n        } else if (year <= 999) {\r\n            return 1900 + year;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function preprocessRFC2822(s) {\r\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\r\n        return s\r\n            .replace(/\\([^)]*\\)|[\\n\\t]/g, ' ')\r\n            .replace(/(\\s\\s+)/g, ' ')\r\n            .replace(/^\\s\\s*/, '')\r\n            .replace(/\\s\\s*$/, '');\r\n    }\r\n\r\n    function checkWeekday(weekdayStr, parsedInput, config) {\r\n        if (weekdayStr) {\r\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\r\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\r\n                weekdayActual = new Date(\r\n                    parsedInput[0],\r\n                    parsedInput[1],\r\n                    parsedInput[2]\r\n                ).getDay();\r\n            if (weekdayProvided !== weekdayActual) {\r\n                getParsingFlags(config).weekdayMismatch = true;\r\n                config._isValid = false;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\r\n        if (obsOffset) {\r\n            return obsOffsets[obsOffset];\r\n        } else if (militaryOffset) {\r\n            // the only allowed military tz is Z\r\n            return 0;\r\n        } else {\r\n            var hm = parseInt(numOffset, 10),\r\n                m = hm % 100,\r\n                h = (hm - m) / 100;\r\n            return h * 60 + m;\r\n        }\r\n    }\r\n\r\n    // date and time from ref 2822 format\r\n    function configFromRFC2822(config) {\r\n        var match = rfc2822.exec(preprocessRFC2822(config._i)),\r\n            parsedArray;\r\n        if (match) {\r\n            parsedArray = extractFromRFC2822Strings(\r\n                match[4],\r\n                match[3],\r\n                match[2],\r\n                match[5],\r\n                match[6],\r\n                match[7]\r\n            );\r\n            if (!checkWeekday(match[1], parsedArray, config)) {\r\n                return;\r\n            }\r\n\r\n            config._a = parsedArray;\r\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\r\n\r\n            config._d = createUTCDate.apply(null, config._a);\r\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\r\n\r\n            getParsingFlags(config).rfc2822 = true;\r\n        } else {\r\n            config._isValid = false;\r\n        }\r\n    }\r\n\r\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\r\n    function configFromString(config) {\r\n        var matched = aspNetJsonRegex.exec(config._i);\r\n        if (matched !== null) {\r\n            config._d = new Date(+matched[1]);\r\n            return;\r\n        }\r\n\r\n        configFromISO(config);\r\n        if (config._isValid === false) {\r\n            delete config._isValid;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        configFromRFC2822(config);\r\n        if (config._isValid === false) {\r\n            delete config._isValid;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        if (config._strict) {\r\n            config._isValid = false;\r\n        } else {\r\n            // Final attempt, use Input Fallback\r\n            hooks.createFromInputFallback(config);\r\n        }\r\n    }\r\n\r\n    hooks.createFromInputFallback = deprecate(\r\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\r\n            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\r\n            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',\r\n        function (config) {\r\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\r\n        }\r\n    );\r\n\r\n    // Pick the first defined of two or three arguments.\r\n    function defaults(a, b, c) {\r\n        if (a != null) {\r\n            return a;\r\n        }\r\n        if (b != null) {\r\n            return b;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function currentDateArray(config) {\r\n        // hooks is actually the exported moment object\r\n        var nowValue = new Date(hooks.now());\r\n        if (config._useUTC) {\r\n            return [\r\n                nowValue.getUTCFullYear(),\r\n                nowValue.getUTCMonth(),\r\n                nowValue.getUTCDate(),\r\n            ];\r\n        }\r\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\r\n    }\r\n\r\n    // convert an array to a date.\r\n    // the array should mirror the parameters below\r\n    // note: all values past the year are optional and will default to the lowest possible value.\r\n    // [year, month, day , hour, minute, second, millisecond]\r\n    function configFromArray(config) {\r\n        var i,\r\n            date,\r\n            input = [],\r\n            currentDate,\r\n            expectedWeekday,\r\n            yearToUse;\r\n\r\n        if (config._d) {\r\n            return;\r\n        }\r\n\r\n        currentDate = currentDateArray(config);\r\n\r\n        //compute day of the year from weeks and weekdays\r\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\r\n            dayOfYearFromWeekInfo(config);\r\n        }\r\n\r\n        //if the day of the year is set, figure out what it is\r\n        if (config._dayOfYear != null) {\r\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\r\n\r\n            if (\r\n                config._dayOfYear > daysInYear(yearToUse) ||\r\n                config._dayOfYear === 0\r\n            ) {\r\n                getParsingFlags(config)._overflowDayOfYear = true;\r\n            }\r\n\r\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\r\n            config._a[MONTH] = date.getUTCMonth();\r\n            config._a[DATE] = date.getUTCDate();\r\n        }\r\n\r\n        // Default to current date.\r\n        // * if no year, month, day of month are given, default to today\r\n        // * if day of month is given, default month and year\r\n        // * if month is given, default only year\r\n        // * if year is given, don't default anything\r\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\r\n            config._a[i] = input[i] = currentDate[i];\r\n        }\r\n\r\n        // Zero out whatever was not defaulted, including time\r\n        for (; i < 7; i++) {\r\n            config._a[i] = input[i] =\r\n                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];\r\n        }\r\n\r\n        // Check for 24:00:00.000\r\n        if (\r\n            config._a[HOUR] === 24 &&\r\n            config._a[MINUTE] === 0 &&\r\n            config._a[SECOND] === 0 &&\r\n            config._a[MILLISECOND] === 0\r\n        ) {\r\n            config._nextDay = true;\r\n            config._a[HOUR] = 0;\r\n        }\r\n\r\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(\r\n            null,\r\n            input\r\n        );\r\n        expectedWeekday = config._useUTC\r\n            ? config._d.getUTCDay()\r\n            : config._d.getDay();\r\n\r\n        // Apply timezone offset from input. The actual utcOffset can be changed\r\n        // with parseZone.\r\n        if (config._tzm != null) {\r\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\r\n        }\r\n\r\n        if (config._nextDay) {\r\n            config._a[HOUR] = 24;\r\n        }\r\n\r\n        // check for mismatching day of week\r\n        if (\r\n            config._w &&\r\n            typeof config._w.d !== 'undefined' &&\r\n            config._w.d !== expectedWeekday\r\n        ) {\r\n            getParsingFlags(config).weekdayMismatch = true;\r\n        }\r\n    }\r\n\r\n    function dayOfYearFromWeekInfo(config) {\r\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\r\n\r\n        w = config._w;\r\n        if (w.GG != null || w.W != null || w.E != null) {\r\n            dow = 1;\r\n            doy = 4;\r\n\r\n            // TODO: We need to take the current isoWeekYear, but that depends on\r\n            // how we interpret now (local, utc, fixed offset). So create\r\n            // a now version of current config (take local/utc/offset flags, and\r\n            // create now).\r\n            weekYear = defaults(\r\n                w.GG,\r\n                config._a[YEAR],\r\n                weekOfYear(createLocal(), 1, 4).year\r\n            );\r\n            week = defaults(w.W, 1);\r\n            weekday = defaults(w.E, 1);\r\n            if (weekday < 1 || weekday > 7) {\r\n                weekdayOverflow = true;\r\n            }\r\n        } else {\r\n            dow = config._locale._week.dow;\r\n            doy = config._locale._week.doy;\r\n\r\n            curWeek = weekOfYear(createLocal(), dow, doy);\r\n\r\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\r\n\r\n            // Default to current week.\r\n            week = defaults(w.w, curWeek.week);\r\n\r\n            if (w.d != null) {\r\n                // weekday -- low day numbers are considered next week\r\n                weekday = w.d;\r\n                if (weekday < 0 || weekday > 6) {\r\n                    weekdayOverflow = true;\r\n                }\r\n            } else if (w.e != null) {\r\n                // local weekday -- counting starts from beginning of week\r\n                weekday = w.e + dow;\r\n                if (w.e < 0 || w.e > 6) {\r\n                    weekdayOverflow = true;\r\n                }\r\n            } else {\r\n                // default to beginning of week\r\n                weekday = dow;\r\n            }\r\n        }\r\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\r\n            getParsingFlags(config)._overflowWeeks = true;\r\n        } else if (weekdayOverflow != null) {\r\n            getParsingFlags(config)._overflowWeekday = true;\r\n        } else {\r\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\r\n            config._a[YEAR] = temp.year;\r\n            config._dayOfYear = temp.dayOfYear;\r\n        }\r\n    }\r\n\r\n    // constant that refers to the ISO standard\r\n    hooks.ISO_8601 = function () {};\r\n\r\n    // constant that refers to the RFC 2822 form\r\n    hooks.RFC_2822 = function () {};\r\n\r\n    // date from string and format string\r\n    function configFromStringAndFormat(config) {\r\n        // TODO: Move this to another part of the creation flow to prevent circular deps\r\n        if (config._f === hooks.ISO_8601) {\r\n            configFromISO(config);\r\n            return;\r\n        }\r\n        if (config._f === hooks.RFC_2822) {\r\n            configFromRFC2822(config);\r\n            return;\r\n        }\r\n        config._a = [];\r\n        getParsingFlags(config).empty = true;\r\n\r\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\r\n        var string = '' + config._i,\r\n            i,\r\n            parsedInput,\r\n            tokens,\r\n            token,\r\n            skipped,\r\n            stringLength = string.length,\r\n            totalParsedInputLength = 0,\r\n            era;\r\n\r\n        tokens =\r\n            expandFormat(config._f, config._locale).match(formattingTokens) || [];\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token = tokens[i];\r\n            parsedInput = (string.match(getParseRegexForToken(token, config)) ||\r\n                [])[0];\r\n            if (parsedInput) {\r\n                skipped = string.substr(0, string.indexOf(parsedInput));\r\n                if (skipped.length > 0) {\r\n                    getParsingFlags(config).unusedInput.push(skipped);\r\n                }\r\n                string = string.slice(\r\n                    string.indexOf(parsedInput) + parsedInput.length\r\n                );\r\n                totalParsedInputLength += parsedInput.length;\r\n            }\r\n            // don't parse if it's not a known token\r\n            if (formatTokenFunctions[token]) {\r\n                if (parsedInput) {\r\n                    getParsingFlags(config).empty = false;\r\n                } else {\r\n                    getParsingFlags(config).unusedTokens.push(token);\r\n                }\r\n                addTimeToArrayFromToken(token, parsedInput, config);\r\n            } else if (config._strict && !parsedInput) {\r\n                getParsingFlags(config).unusedTokens.push(token);\r\n            }\r\n        }\r\n\r\n        // add remaining unparsed input length to the string\r\n        getParsingFlags(config).charsLeftOver =\r\n            stringLength - totalParsedInputLength;\r\n        if (string.length > 0) {\r\n            getParsingFlags(config).unusedInput.push(string);\r\n        }\r\n\r\n        // clear _12h flag if hour is <= 12\r\n        if (\r\n            config._a[HOUR] <= 12 &&\r\n            getParsingFlags(config).bigHour === true &&\r\n            config._a[HOUR] > 0\r\n        ) {\r\n            getParsingFlags(config).bigHour = undefined;\r\n        }\r\n\r\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\r\n        getParsingFlags(config).meridiem = config._meridiem;\r\n        // handle meridiem\r\n        config._a[HOUR] = meridiemFixWrap(\r\n            config._locale,\r\n            config._a[HOUR],\r\n            config._meridiem\r\n        );\r\n\r\n        // handle era\r\n        era = getParsingFlags(config).era;\r\n        if (era !== null) {\r\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\r\n        }\r\n\r\n        configFromArray(config);\r\n        checkOverflow(config);\r\n    }\r\n\r\n    function meridiemFixWrap(locale, hour, meridiem) {\r\n        var isPm;\r\n\r\n        if (meridiem == null) {\r\n            // nothing to do\r\n            return hour;\r\n        }\r\n        if (locale.meridiemHour != null) {\r\n            return locale.meridiemHour(hour, meridiem);\r\n        } else if (locale.isPM != null) {\r\n            // Fallback\r\n            isPm = locale.isPM(meridiem);\r\n            if (isPm && hour < 12) {\r\n                hour += 12;\r\n            }\r\n            if (!isPm && hour === 12) {\r\n                hour = 0;\r\n            }\r\n            return hour;\r\n        } else {\r\n            // this is not supposed to happen\r\n            return hour;\r\n        }\r\n    }\r\n\r\n    // date from string and array of format strings\r\n    function configFromStringAndArray(config) {\r\n        var tempConfig,\r\n            bestMoment,\r\n            scoreToBeat,\r\n            i,\r\n            currentScore,\r\n            validFormatFound,\r\n            bestFormatIsValid = false;\r\n\r\n        if (config._f.length === 0) {\r\n            getParsingFlags(config).invalidFormat = true;\r\n            config._d = new Date(NaN);\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < config._f.length; i++) {\r\n            currentScore = 0;\r\n            validFormatFound = false;\r\n            tempConfig = copyConfig({}, config);\r\n            if (config._useUTC != null) {\r\n                tempConfig._useUTC = config._useUTC;\r\n            }\r\n            tempConfig._f = config._f[i];\r\n            configFromStringAndFormat(tempConfig);\r\n\r\n            if (isValid(tempConfig)) {\r\n                validFormatFound = true;\r\n            }\r\n\r\n            // if there is any input that was not parsed add a penalty for that format\r\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\r\n\r\n            //or tokens\r\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\r\n\r\n            getParsingFlags(tempConfig).score = currentScore;\r\n\r\n            if (!bestFormatIsValid) {\r\n                if (\r\n                    scoreToBeat == null ||\r\n                    currentScore < scoreToBeat ||\r\n                    validFormatFound\r\n                ) {\r\n                    scoreToBeat = currentScore;\r\n                    bestMoment = tempConfig;\r\n                    if (validFormatFound) {\r\n                        bestFormatIsValid = true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (currentScore < scoreToBeat) {\r\n                    scoreToBeat = currentScore;\r\n                    bestMoment = tempConfig;\r\n                }\r\n            }\r\n        }\r\n\r\n        extend(config, bestMoment || tempConfig);\r\n    }\r\n\r\n    function configFromObject(config) {\r\n        if (config._d) {\r\n            return;\r\n        }\r\n\r\n        var i = normalizeObjectUnits(config._i),\r\n            dayOrDate = i.day === undefined ? i.date : i.day;\r\n        config._a = map(\r\n            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],\r\n            function (obj) {\r\n                return obj && parseInt(obj, 10);\r\n            }\r\n        );\r\n\r\n        configFromArray(config);\r\n    }\r\n\r\n    function createFromConfig(config) {\r\n        var res = new Moment(checkOverflow(prepareConfig(config)));\r\n        if (res._nextDay) {\r\n            // Adding is smart enough around DST\r\n            res.add(1, 'd');\r\n            res._nextDay = undefined;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function prepareConfig(config) {\r\n        var input = config._i,\r\n            format = config._f;\r\n\r\n        config._locale = config._locale || getLocale(config._l);\r\n\r\n        if (input === null || (format === undefined && input === '')) {\r\n            return createInvalid({ nullInput: true });\r\n        }\r\n\r\n        if (typeof input === 'string') {\r\n            config._i = input = config._locale.preparse(input);\r\n        }\r\n\r\n        if (isMoment(input)) {\r\n            return new Moment(checkOverflow(input));\r\n        } else if (isDate(input)) {\r\n            config._d = input;\r\n        } else if (isArray(format)) {\r\n            configFromStringAndArray(config);\r\n        } else if (format) {\r\n            configFromStringAndFormat(config);\r\n        } else {\r\n            configFromInput(config);\r\n        }\r\n\r\n        if (!isValid(config)) {\r\n            config._d = null;\r\n        }\r\n\r\n        return config;\r\n    }\r\n\r\n    function configFromInput(config) {\r\n        var input = config._i;\r\n        if (isUndefined(input)) {\r\n            config._d = new Date(hooks.now());\r\n        } else if (isDate(input)) {\r\n            config._d = new Date(input.valueOf());\r\n        } else if (typeof input === 'string') {\r\n            configFromString(config);\r\n        } else if (isArray(input)) {\r\n            config._a = map(input.slice(0), function (obj) {\r\n                return parseInt(obj, 10);\r\n            });\r\n            configFromArray(config);\r\n        } else if (isObject(input)) {\r\n            configFromObject(config);\r\n        } else if (isNumber(input)) {\r\n            // from milliseconds\r\n            config._d = new Date(input);\r\n        } else {\r\n            hooks.createFromInputFallback(config);\r\n        }\r\n    }\r\n\r\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\r\n        var c = {};\r\n\r\n        if (format === true || format === false) {\r\n            strict = format;\r\n            format = undefined;\r\n        }\r\n\r\n        if (locale === true || locale === false) {\r\n            strict = locale;\r\n            locale = undefined;\r\n        }\r\n\r\n        if (\r\n            (isObject(input) && isObjectEmpty(input)) ||\r\n            (isArray(input) && input.length === 0)\r\n        ) {\r\n            input = undefined;\r\n        }\r\n        // object construction must be done this way.\r\n        // https://github.com/moment/moment/issues/1423\r\n        c._isAMomentObject = true;\r\n        c._useUTC = c._isUTC = isUTC;\r\n        c._l = locale;\r\n        c._i = input;\r\n        c._f = format;\r\n        c._strict = strict;\r\n\r\n        return createFromConfig(c);\r\n    }\r\n\r\n    function createLocal(input, format, locale, strict) {\r\n        return createLocalOrUTC(input, format, locale, strict, false);\r\n    }\r\n\r\n    var prototypeMin = deprecate(\r\n            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\r\n            function () {\r\n                var other = createLocal.apply(null, arguments);\r\n                if (this.isValid() && other.isValid()) {\r\n                    return other < this ? this : other;\r\n                } else {\r\n                    return createInvalid();\r\n                }\r\n            }\r\n        ),\r\n        prototypeMax = deprecate(\r\n            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\r\n            function () {\r\n                var other = createLocal.apply(null, arguments);\r\n                if (this.isValid() && other.isValid()) {\r\n                    return other > this ? this : other;\r\n                } else {\r\n                    return createInvalid();\r\n                }\r\n            }\r\n        );\r\n\r\n    // Pick a moment m from moments so that m[fn](other) is true for all\r\n    // other. This relies on the function fn to be transitive.\r\n    //\r\n    // moments should either be an array of moment objects or an array, whose\r\n    // first element is an array of moment objects.\r\n    function pickBy(fn, moments) {\r\n        var res, i;\r\n        if (moments.length === 1 && isArray(moments[0])) {\r\n            moments = moments[0];\r\n        }\r\n        if (!moments.length) {\r\n            return createLocal();\r\n        }\r\n        res = moments[0];\r\n        for (i = 1; i < moments.length; ++i) {\r\n            if (!moments[i].isValid() || moments[i][fn](res)) {\r\n                res = moments[i];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // TODO: Use [].sort instead?\r\n    function min() {\r\n        var args = [].slice.call(arguments, 0);\r\n\r\n        return pickBy('isBefore', args);\r\n    }\r\n\r\n    function max() {\r\n        var args = [].slice.call(arguments, 0);\r\n\r\n        return pickBy('isAfter', args);\r\n    }\r\n\r\n    var now = function () {\r\n        return Date.now ? Date.now() : +new Date();\r\n    };\r\n\r\n    var ordering = [\r\n        'year',\r\n        'quarter',\r\n        'month',\r\n        'week',\r\n        'day',\r\n        'hour',\r\n        'minute',\r\n        'second',\r\n        'millisecond',\r\n    ];\r\n\r\n    function isDurationValid(m) {\r\n        var key,\r\n            unitHasDecimal = false,\r\n            i;\r\n        for (key in m) {\r\n            if (\r\n                hasOwnProp(m, key) &&\r\n                !(\r\n                    indexOf.call(ordering, key) !== -1 &&\r\n                    (m[key] == null || !isNaN(m[key]))\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < ordering.length; ++i) {\r\n            if (m[ordering[i]]) {\r\n                if (unitHasDecimal) {\r\n                    return false; // only allow non-integers for smallest unit\r\n                }\r\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\r\n                    unitHasDecimal = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isValid$1() {\r\n        return this._isValid;\r\n    }\r\n\r\n    function createInvalid$1() {\r\n        return createDuration(NaN);\r\n    }\r\n\r\n    function Duration(duration) {\r\n        var normalizedInput = normalizeObjectUnits(duration),\r\n            years = normalizedInput.year || 0,\r\n            quarters = normalizedInput.quarter || 0,\r\n            months = normalizedInput.month || 0,\r\n            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\r\n            days = normalizedInput.day || 0,\r\n            hours = normalizedInput.hour || 0,\r\n            minutes = normalizedInput.minute || 0,\r\n            seconds = normalizedInput.second || 0,\r\n            milliseconds = normalizedInput.millisecond || 0;\r\n\r\n        this._isValid = isDurationValid(normalizedInput);\r\n\r\n        // representation for dateAddRemove\r\n        this._milliseconds =\r\n            +milliseconds +\r\n            seconds * 1e3 + // 1000\r\n            minutes * 6e4 + // 1000 * 60\r\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\r\n        // Because of dateAddRemove treats 24 hours as different from a\r\n        // day when working around DST, we need to store them separately\r\n        this._days = +days + weeks * 7;\r\n        // It is impossible to translate months into days without knowing\r\n        // which months you are are talking about, so we have to store\r\n        // it separately.\r\n        this._months = +months + quarters * 3 + years * 12;\r\n\r\n        this._data = {};\r\n\r\n        this._locale = getLocale();\r\n\r\n        this._bubble();\r\n    }\r\n\r\n    function isDuration(obj) {\r\n        return obj instanceof Duration;\r\n    }\r\n\r\n    function absRound(number) {\r\n        if (number < 0) {\r\n            return Math.round(-1 * number) * -1;\r\n        } else {\r\n            return Math.round(number);\r\n        }\r\n    }\r\n\r\n    // compare two arrays, return the number of differences\r\n    function compareArrays(array1, array2, dontConvert) {\r\n        var len = Math.min(array1.length, array2.length),\r\n            lengthDiff = Math.abs(array1.length - array2.length),\r\n            diffs = 0,\r\n            i;\r\n        for (i = 0; i < len; i++) {\r\n            if (\r\n                (dontConvert && array1[i] !== array2[i]) ||\r\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))\r\n            ) {\r\n                diffs++;\r\n            }\r\n        }\r\n        return diffs + lengthDiff;\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    function offset(token, separator) {\r\n        addFormatToken(token, 0, 0, function () {\r\n            var offset = this.utcOffset(),\r\n                sign = '+';\r\n            if (offset < 0) {\r\n                offset = -offset;\r\n                sign = '-';\r\n            }\r\n            return (\r\n                sign +\r\n                zeroFill(~~(offset / 60), 2) +\r\n                separator +\r\n                zeroFill(~~offset % 60, 2)\r\n            );\r\n        });\r\n    }\r\n\r\n    offset('Z', ':');\r\n    offset('ZZ', '');\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('Z', matchShortOffset);\r\n    addRegexToken('ZZ', matchShortOffset);\r\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\r\n        config._useUTC = true;\r\n        config._tzm = offsetFromString(matchShortOffset, input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    // timezone chunker\r\n    // '+10:00' > ['10',  '00']\r\n    // '-1530'  > ['-15', '30']\r\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\r\n\r\n    function offsetFromString(matcher, string) {\r\n        var matches = (string || '').match(matcher),\r\n            chunk,\r\n            parts,\r\n            minutes;\r\n\r\n        if (matches === null) {\r\n            return null;\r\n        }\r\n\r\n        chunk = matches[matches.length - 1] || [];\r\n        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\r\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\r\n\r\n        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\r\n    }\r\n\r\n    // Return a moment from input, that is local/utc/zone equivalent to model.\r\n    function cloneWithOffset(input, model) {\r\n        var res, diff;\r\n        if (model._isUTC) {\r\n            res = model.clone();\r\n            diff =\r\n                (isMoment(input) || isDate(input)\r\n                    ? input.valueOf()\r\n                    : createLocal(input).valueOf()) - res.valueOf();\r\n            // Use low-level api, because this fn is low-level api.\r\n            res._d.setTime(res._d.valueOf() + diff);\r\n            hooks.updateOffset(res, false);\r\n            return res;\r\n        } else {\r\n            return createLocal(input).local();\r\n        }\r\n    }\r\n\r\n    function getDateOffset(m) {\r\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\r\n        // https://github.com/moment/moment/pull/1871\r\n        return -Math.round(m._d.getTimezoneOffset());\r\n    }\r\n\r\n    // HOOKS\r\n\r\n    // This function will be called whenever a moment is mutated.\r\n    // It is intended to keep the offset in sync with the timezone.\r\n    hooks.updateOffset = function () {};\r\n\r\n    // MOMENTS\r\n\r\n    // keepLocalTime = true means only change the timezone, without\r\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\r\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\r\n    // +0200, so we adjust the time as needed, to be valid.\r\n    //\r\n    // Keeping the time actually adds/subtracts (one hour)\r\n    // from the actual represented time. That is why we call updateOffset\r\n    // a second time. In case it wants us to change the offset again\r\n    // _changeInProgress == true case, then we have to adjust, because\r\n    // there is no such time in the given timezone.\r\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\r\n        var offset = this._offset || 0,\r\n            localAdjust;\r\n        if (!this.isValid()) {\r\n            return input != null ? this : NaN;\r\n        }\r\n        if (input != null) {\r\n            if (typeof input === 'string') {\r\n                input = offsetFromString(matchShortOffset, input);\r\n                if (input === null) {\r\n                    return this;\r\n                }\r\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\r\n                input = input * 60;\r\n            }\r\n            if (!this._isUTC && keepLocalTime) {\r\n                localAdjust = getDateOffset(this);\r\n            }\r\n            this._offset = input;\r\n            this._isUTC = true;\r\n            if (localAdjust != null) {\r\n                this.add(localAdjust, 'm');\r\n            }\r\n            if (offset !== input) {\r\n                if (!keepLocalTime || this._changeInProgress) {\r\n                    addSubtract(\r\n                        this,\r\n                        createDuration(input - offset, 'm'),\r\n                        1,\r\n                        false\r\n                    );\r\n                } else if (!this._changeInProgress) {\r\n                    this._changeInProgress = true;\r\n                    hooks.updateOffset(this, true);\r\n                    this._changeInProgress = null;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this._isUTC ? offset : getDateOffset(this);\r\n        }\r\n    }\r\n\r\n    function getSetZone(input, keepLocalTime) {\r\n        if (input != null) {\r\n            if (typeof input !== 'string') {\r\n                input = -input;\r\n            }\r\n\r\n            this.utcOffset(input, keepLocalTime);\r\n\r\n            return this;\r\n        } else {\r\n            return -this.utcOffset();\r\n        }\r\n    }\r\n\r\n    function setOffsetToUTC(keepLocalTime) {\r\n        return this.utcOffset(0, keepLocalTime);\r\n    }\r\n\r\n    function setOffsetToLocal(keepLocalTime) {\r\n        if (this._isUTC) {\r\n            this.utcOffset(0, keepLocalTime);\r\n            this._isUTC = false;\r\n\r\n            if (keepLocalTime) {\r\n                this.subtract(getDateOffset(this), 'm');\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function setOffsetToParsedOffset() {\r\n        if (this._tzm != null) {\r\n            this.utcOffset(this._tzm, false, true);\r\n        } else if (typeof this._i === 'string') {\r\n            var tZone = offsetFromString(matchOffset, this._i);\r\n            if (tZone != null) {\r\n                this.utcOffset(tZone);\r\n            } else {\r\n                this.utcOffset(0, true);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function hasAlignedHourOffset(input) {\r\n        if (!this.isValid()) {\r\n            return false;\r\n        }\r\n        input = input ? createLocal(input).utcOffset() : 0;\r\n\r\n        return (this.utcOffset() - input) % 60 === 0;\r\n    }\r\n\r\n    function isDaylightSavingTime() {\r\n        return (\r\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\r\n            this.utcOffset() > this.clone().month(5).utcOffset()\r\n        );\r\n    }\r\n\r\n    function isDaylightSavingTimeShifted() {\r\n        if (!isUndefined(this._isDSTShifted)) {\r\n            return this._isDSTShifted;\r\n        }\r\n\r\n        var c = {},\r\n            other;\r\n\r\n        copyConfig(c, this);\r\n        c = prepareConfig(c);\r\n\r\n        if (c._a) {\r\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\r\n            this._isDSTShifted =\r\n                this.isValid() && compareArrays(c._a, other.toArray()) > 0;\r\n        } else {\r\n            this._isDSTShifted = false;\r\n        }\r\n\r\n        return this._isDSTShifted;\r\n    }\r\n\r\n    function isLocal() {\r\n        return this.isValid() ? !this._isUTC : false;\r\n    }\r\n\r\n    function isUtcOffset() {\r\n        return this.isValid() ? this._isUTC : false;\r\n    }\r\n\r\n    function isUtc() {\r\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\r\n    }\r\n\r\n    // ASP.NET json date format regex\r\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\r\n        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\r\n        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\r\n        // and further modified to allow for strings containing both week and day\r\n        isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\r\n\r\n    function createDuration(input, key) {\r\n        var duration = input,\r\n            // matching against regexp is expensive, do it on demand\r\n            match = null,\r\n            sign,\r\n            ret,\r\n            diffRes;\r\n\r\n        if (isDuration(input)) {\r\n            duration = {\r\n                ms: input._milliseconds,\r\n                d: input._days,\r\n                M: input._months,\r\n            };\r\n        } else if (isNumber(input) || !isNaN(+input)) {\r\n            duration = {};\r\n            if (key) {\r\n                duration[key] = +input;\r\n            } else {\r\n                duration.milliseconds = +input;\r\n            }\r\n        } else if ((match = aspNetRegex.exec(input))) {\r\n            sign = match[1] === '-' ? -1 : 1;\r\n            duration = {\r\n                y: 0,\r\n                d: toInt(match[DATE]) * sign,\r\n                h: toInt(match[HOUR]) * sign,\r\n                m: toInt(match[MINUTE]) * sign,\r\n                s: toInt(match[SECOND]) * sign,\r\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match\r\n            };\r\n        } else if ((match = isoRegex.exec(input))) {\r\n            sign = match[1] === '-' ? -1 : 1;\r\n            duration = {\r\n                y: parseIso(match[2], sign),\r\n                M: parseIso(match[3], sign),\r\n                w: parseIso(match[4], sign),\r\n                d: parseIso(match[5], sign),\r\n                h: parseIso(match[6], sign),\r\n                m: parseIso(match[7], sign),\r\n                s: parseIso(match[8], sign),\r\n            };\r\n        } else if (duration == null) {\r\n            // checks for null or undefined\r\n            duration = {};\r\n        } else if (\r\n            typeof duration === 'object' &&\r\n            ('from' in duration || 'to' in duration)\r\n        ) {\r\n            diffRes = momentsDifference(\r\n                createLocal(duration.from),\r\n                createLocal(duration.to)\r\n            );\r\n\r\n            duration = {};\r\n            duration.ms = diffRes.milliseconds;\r\n            duration.M = diffRes.months;\r\n        }\r\n\r\n        ret = new Duration(duration);\r\n\r\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\r\n            ret._locale = input._locale;\r\n        }\r\n\r\n        if (isDuration(input) && hasOwnProp(input, '_isValid')) {\r\n            ret._isValid = input._isValid;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    createDuration.fn = Duration.prototype;\r\n    createDuration.invalid = createInvalid$1;\r\n\r\n    function parseIso(inp, sign) {\r\n        // We'd normally use ~~inp for this, but unfortunately it also\r\n        // converts floats to ints.\r\n        // inp may be undefined, so careful calling replace on it.\r\n        var res = inp && parseFloat(inp.replace(',', '.'));\r\n        // apply sign while we're at it\r\n        return (isNaN(res) ? 0 : res) * sign;\r\n    }\r\n\r\n    function positiveMomentsDifference(base, other) {\r\n        var res = {};\r\n\r\n        res.months =\r\n            other.month() - base.month() + (other.year() - base.year()) * 12;\r\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\r\n            --res.months;\r\n        }\r\n\r\n        res.milliseconds = +other - +base.clone().add(res.months, 'M');\r\n\r\n        return res;\r\n    }\r\n\r\n    function momentsDifference(base, other) {\r\n        var res;\r\n        if (!(base.isValid() && other.isValid())) {\r\n            return { milliseconds: 0, months: 0 };\r\n        }\r\n\r\n        other = cloneWithOffset(other, base);\r\n        if (base.isBefore(other)) {\r\n            res = positiveMomentsDifference(base, other);\r\n        } else {\r\n            res = positiveMomentsDifference(other, base);\r\n            res.milliseconds = -res.milliseconds;\r\n            res.months = -res.months;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    // TODO: remove 'name' arg after deprecation is removed\r\n    function createAdder(direction, name) {\r\n        return function (val, period) {\r\n            var dur, tmp;\r\n            //invert the arguments, but complain about it\r\n            if (period !== null && !isNaN(+period)) {\r\n                deprecateSimple(\r\n                    name,\r\n                    'moment().' +\r\n                        name +\r\n                        '(period, number) is deprecated. Please use moment().' +\r\n                        name +\r\n                        '(number, period). ' +\r\n                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'\r\n                );\r\n                tmp = val;\r\n                val = period;\r\n                period = tmp;\r\n            }\r\n\r\n            dur = createDuration(val, period);\r\n            addSubtract(this, dur, direction);\r\n            return this;\r\n        };\r\n    }\r\n\r\n    function addSubtract(mom, duration, isAdding, updateOffset) {\r\n        var milliseconds = duration._milliseconds,\r\n            days = absRound(duration._days),\r\n            months = absRound(duration._months);\r\n\r\n        if (!mom.isValid()) {\r\n            // No op\r\n            return;\r\n        }\r\n\r\n        updateOffset = updateOffset == null ? true : updateOffset;\r\n\r\n        if (months) {\r\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\r\n        }\r\n        if (days) {\r\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\r\n        }\r\n        if (milliseconds) {\r\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\r\n        }\r\n        if (updateOffset) {\r\n            hooks.updateOffset(mom, days || months);\r\n        }\r\n    }\r\n\r\n    var add = createAdder(1, 'add'),\r\n        subtract = createAdder(-1, 'subtract');\r\n\r\n    function isString(input) {\r\n        return typeof input === 'string' || input instanceof String;\r\n    }\r\n\r\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\r\n    function isMomentInput(input) {\r\n        return (\r\n            isMoment(input) ||\r\n            isDate(input) ||\r\n            isString(input) ||\r\n            isNumber(input) ||\r\n            isNumberOrStringArray(input) ||\r\n            isMomentInputObject(input) ||\r\n            input === null ||\r\n            input === undefined\r\n        );\r\n    }\r\n\r\n    function isMomentInputObject(input) {\r\n        var objectTest = isObject(input) && !isObjectEmpty(input),\r\n            propertyTest = false,\r\n            properties = [\r\n                'years',\r\n                'year',\r\n                'y',\r\n                'months',\r\n                'month',\r\n                'M',\r\n                'days',\r\n                'day',\r\n                'd',\r\n                'dates',\r\n                'date',\r\n                'D',\r\n                'hours',\r\n                'hour',\r\n                'h',\r\n                'minutes',\r\n                'minute',\r\n                'm',\r\n                'seconds',\r\n                'second',\r\n                's',\r\n                'milliseconds',\r\n                'millisecond',\r\n                'ms',\r\n            ],\r\n            i,\r\n            property;\r\n\r\n        for (i = 0; i < properties.length; i += 1) {\r\n            property = properties[i];\r\n            propertyTest = propertyTest || hasOwnProp(input, property);\r\n        }\r\n\r\n        return objectTest && propertyTest;\r\n    }\r\n\r\n    function isNumberOrStringArray(input) {\r\n        var arrayTest = isArray(input),\r\n            dataTypeTest = false;\r\n        if (arrayTest) {\r\n            dataTypeTest =\r\n                input.filter(function (item) {\r\n                    return !isNumber(item) && isString(input);\r\n                }).length === 0;\r\n        }\r\n        return arrayTest && dataTypeTest;\r\n    }\r\n\r\n    function isCalendarSpec(input) {\r\n        var objectTest = isObject(input) && !isObjectEmpty(input),\r\n            propertyTest = false,\r\n            properties = [\r\n                'sameDay',\r\n                'nextDay',\r\n                'lastDay',\r\n                'nextWeek',\r\n                'lastWeek',\r\n                'sameElse',\r\n            ],\r\n            i,\r\n            property;\r\n\r\n        for (i = 0; i < properties.length; i += 1) {\r\n            property = properties[i];\r\n            propertyTest = propertyTest || hasOwnProp(input, property);\r\n        }\r\n\r\n        return objectTest && propertyTest;\r\n    }\r\n\r\n    function getCalendarFormat(myMoment, now) {\r\n        var diff = myMoment.diff(now, 'days', true);\r\n        return diff < -6\r\n            ? 'sameElse'\r\n            : diff < -1\r\n            ? 'lastWeek'\r\n            : diff < 0\r\n            ? 'lastDay'\r\n            : diff < 1\r\n            ? 'sameDay'\r\n            : diff < 2\r\n            ? 'nextDay'\r\n            : diff < 7\r\n            ? 'nextWeek'\r\n            : 'sameElse';\r\n    }\r\n\r\n    function calendar$1(time, formats) {\r\n        // Support for single parameter, formats only overload to the calendar function\r\n        if (arguments.length === 1) {\r\n            if (!arguments[0]) {\r\n                time = undefined;\r\n                formats = undefined;\r\n            } else if (isMomentInput(arguments[0])) {\r\n                time = arguments[0];\r\n                formats = undefined;\r\n            } else if (isCalendarSpec(arguments[0])) {\r\n                formats = arguments[0];\r\n                time = undefined;\r\n            }\r\n        }\r\n        // We want to compare the start of today, vs this.\r\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\r\n        var now = time || createLocal(),\r\n            sod = cloneWithOffset(now, this).startOf('day'),\r\n            format = hooks.calendarFormat(this, sod) || 'sameElse',\r\n            output =\r\n                formats &&\r\n                (isFunction(formats[format])\r\n                    ? formats[format].call(this, now)\r\n                    : formats[format]);\r\n\r\n        return this.format(\r\n            output || this.localeData().calendar(format, this, createLocal(now))\r\n        );\r\n    }\r\n\r\n    function clone() {\r\n        return new Moment(this);\r\n    }\r\n\r\n    function isAfter(input, units) {\r\n        var localInput = isMoment(input) ? input : createLocal(input);\r\n        if (!(this.isValid() && localInput.isValid())) {\r\n            return false;\r\n        }\r\n        units = normalizeUnits(units) || 'millisecond';\r\n        if (units === 'millisecond') {\r\n            return this.valueOf() > localInput.valueOf();\r\n        } else {\r\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\r\n        }\r\n    }\r\n\r\n    function isBefore(input, units) {\r\n        var localInput = isMoment(input) ? input : createLocal(input);\r\n        if (!(this.isValid() && localInput.isValid())) {\r\n            return false;\r\n        }\r\n        units = normalizeUnits(units) || 'millisecond';\r\n        if (units === 'millisecond') {\r\n            return this.valueOf() < localInput.valueOf();\r\n        } else {\r\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\r\n        }\r\n    }\r\n\r\n    function isBetween(from, to, units, inclusivity) {\r\n        var localFrom = isMoment(from) ? from : createLocal(from),\r\n            localTo = isMoment(to) ? to : createLocal(to);\r\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\r\n            return false;\r\n        }\r\n        inclusivity = inclusivity || '()';\r\n        return (\r\n            (inclusivity[0] === '('\r\n                ? this.isAfter(localFrom, units)\r\n                : !this.isBefore(localFrom, units)) &&\r\n            (inclusivity[1] === ')'\r\n                ? this.isBefore(localTo, units)\r\n                : !this.isAfter(localTo, units))\r\n        );\r\n    }\r\n\r\n    function isSame(input, units) {\r\n        var localInput = isMoment(input) ? input : createLocal(input),\r\n            inputMs;\r\n        if (!(this.isValid() && localInput.isValid())) {\r\n            return false;\r\n        }\r\n        units = normalizeUnits(units) || 'millisecond';\r\n        if (units === 'millisecond') {\r\n            return this.valueOf() === localInput.valueOf();\r\n        } else {\r\n            inputMs = localInput.valueOf();\r\n            return (\r\n                this.clone().startOf(units).valueOf() <= inputMs &&\r\n                inputMs <= this.clone().endOf(units).valueOf()\r\n            );\r\n        }\r\n    }\r\n\r\n    function isSameOrAfter(input, units) {\r\n        return this.isSame(input, units) || this.isAfter(input, units);\r\n    }\r\n\r\n    function isSameOrBefore(input, units) {\r\n        return this.isSame(input, units) || this.isBefore(input, units);\r\n    }\r\n\r\n    function diff(input, units, asFloat) {\r\n        var that, zoneDelta, output;\r\n\r\n        if (!this.isValid()) {\r\n            return NaN;\r\n        }\r\n\r\n        that = cloneWithOffset(input, this);\r\n\r\n        if (!that.isValid()) {\r\n            return NaN;\r\n        }\r\n\r\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\r\n\r\n        units = normalizeUnits(units);\r\n\r\n        switch (units) {\r\n            case 'year':\r\n                output = monthDiff(this, that) / 12;\r\n                break;\r\n            case 'month':\r\n                output = monthDiff(this, that);\r\n                break;\r\n            case 'quarter':\r\n                output = monthDiff(this, that) / 3;\r\n                break;\r\n            case 'second':\r\n                output = (this - that) / 1e3;\r\n                break; // 1000\r\n            case 'minute':\r\n                output = (this - that) / 6e4;\r\n                break; // 1000 * 60\r\n            case 'hour':\r\n                output = (this - that) / 36e5;\r\n                break; // 1000 * 60 * 60\r\n            case 'day':\r\n                output = (this - that - zoneDelta) / 864e5;\r\n                break; // 1000 * 60 * 60 * 24, negate dst\r\n            case 'week':\r\n                output = (this - that - zoneDelta) / 6048e5;\r\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\r\n            default:\r\n                output = this - that;\r\n        }\r\n\r\n        return asFloat ? output : absFloor(output);\r\n    }\r\n\r\n    function monthDiff(a, b) {\r\n        if (a.date() < b.date()) {\r\n            // end-of-month calculations work correct when the start month has more\r\n            // days than the end month.\r\n            return -monthDiff(b, a);\r\n        }\r\n        // difference in months\r\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\r\n            // b is in (anchor - 1 month, anchor + 1 month)\r\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\r\n            anchor2,\r\n            adjust;\r\n\r\n        if (b - anchor < 0) {\r\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\r\n            // linear across the month\r\n            adjust = (b - anchor) / (anchor - anchor2);\r\n        } else {\r\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\r\n            // linear across the month\r\n            adjust = (b - anchor) / (anchor2 - anchor);\r\n        }\r\n\r\n        //check for negative zero, return zero if negative zero\r\n        return -(wholeMonthDiff + adjust) || 0;\r\n    }\r\n\r\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\r\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\r\n\r\n    function toString() {\r\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\r\n    }\r\n\r\n    function toISOString(keepOffset) {\r\n        if (!this.isValid()) {\r\n            return null;\r\n        }\r\n        var utc = keepOffset !== true,\r\n            m = utc ? this.clone().utc() : this;\r\n        if (m.year() < 0 || m.year() > 9999) {\r\n            return formatMoment(\r\n                m,\r\n                utc\r\n                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'\r\n                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'\r\n            );\r\n        }\r\n        if (isFunction(Date.prototype.toISOString)) {\r\n            // native implementation is ~50x faster, use it when we can\r\n            if (utc) {\r\n                return this.toDate().toISOString();\r\n            } else {\r\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)\r\n                    .toISOString()\r\n                    .replace('Z', formatMoment(m, 'Z'));\r\n            }\r\n        }\r\n        return formatMoment(\r\n            m,\r\n            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Return a human readable representation of a moment that can\r\n     * also be evaluated to get a new moment which is the same\r\n     *\r\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\r\n     */\r\n    function inspect() {\r\n        if (!this.isValid()) {\r\n            return 'moment.invalid(/* ' + this._i + ' */)';\r\n        }\r\n        var func = 'moment',\r\n            zone = '',\r\n            prefix,\r\n            year,\r\n            datetime,\r\n            suffix;\r\n        if (!this.isLocal()) {\r\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\r\n            zone = 'Z';\r\n        }\r\n        prefix = '[' + func + '(\"]';\r\n        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\r\n        datetime = '-MM-DD[T]HH:mm:ss.SSS';\r\n        suffix = zone + '[\")]';\r\n\r\n        return this.format(prefix + year + datetime + suffix);\r\n    }\r\n\r\n    function format(inputString) {\r\n        if (!inputString) {\r\n            inputString = this.isUtc()\r\n                ? hooks.defaultFormatUtc\r\n                : hooks.defaultFormat;\r\n        }\r\n        var output = formatMoment(this, inputString);\r\n        return this.localeData().postformat(output);\r\n    }\r\n\r\n    function from(time, withoutSuffix) {\r\n        if (\r\n            this.isValid() &&\r\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\r\n        ) {\r\n            return createDuration({ to: this, from: time })\r\n                .locale(this.locale())\r\n                .humanize(!withoutSuffix);\r\n        } else {\r\n            return this.localeData().invalidDate();\r\n        }\r\n    }\r\n\r\n    function fromNow(withoutSuffix) {\r\n        return this.from(createLocal(), withoutSuffix);\r\n    }\r\n\r\n    function to(time, withoutSuffix) {\r\n        if (\r\n            this.isValid() &&\r\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\r\n        ) {\r\n            return createDuration({ from: this, to: time })\r\n                .locale(this.locale())\r\n                .humanize(!withoutSuffix);\r\n        } else {\r\n            return this.localeData().invalidDate();\r\n        }\r\n    }\r\n\r\n    function toNow(withoutSuffix) {\r\n        return this.to(createLocal(), withoutSuffix);\r\n    }\r\n\r\n    // If passed a locale key, it will set the locale for this\r\n    // instance.  Otherwise, it will return the locale configuration\r\n    // variables for this instance.\r\n    function locale(key) {\r\n        var newLocaleData;\r\n\r\n        if (key === undefined) {\r\n            return this._locale._abbr;\r\n        } else {\r\n            newLocaleData = getLocale(key);\r\n            if (newLocaleData != null) {\r\n                this._locale = newLocaleData;\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    var lang = deprecate(\r\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\r\n        function (key) {\r\n            if (key === undefined) {\r\n                return this.localeData();\r\n            } else {\r\n                return this.locale(key);\r\n            }\r\n        }\r\n    );\r\n\r\n    function localeData() {\r\n        return this._locale;\r\n    }\r\n\r\n    var MS_PER_SECOND = 1000,\r\n        MS_PER_MINUTE = 60 * MS_PER_SECOND,\r\n        MS_PER_HOUR = 60 * MS_PER_MINUTE,\r\n        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\r\n\r\n    // actual modulo - handles negative numbers (for dates before 1970):\r\n    function mod$1(dividend, divisor) {\r\n        return ((dividend % divisor) + divisor) % divisor;\r\n    }\r\n\r\n    function localStartOfDate(y, m, d) {\r\n        // the date constructor remaps years 0-99 to 1900-1999\r\n        if (y < 100 && y >= 0) {\r\n            // preserve leap years using a full 400 year cycle, then reset\r\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\r\n        } else {\r\n            return new Date(y, m, d).valueOf();\r\n        }\r\n    }\r\n\r\n    function utcStartOfDate(y, m, d) {\r\n        // Date.UTC remaps years 0-99 to 1900-1999\r\n        if (y < 100 && y >= 0) {\r\n            // preserve leap years using a full 400 year cycle, then reset\r\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\r\n        } else {\r\n            return Date.UTC(y, m, d);\r\n        }\r\n    }\r\n\r\n    function startOf(units) {\r\n        var time, startOfDate;\r\n        units = normalizeUnits(units);\r\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\r\n            return this;\r\n        }\r\n\r\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\r\n\r\n        switch (units) {\r\n            case 'year':\r\n                time = startOfDate(this.year(), 0, 1);\r\n                break;\r\n            case 'quarter':\r\n                time = startOfDate(\r\n                    this.year(),\r\n                    this.month() - (this.month() % 3),\r\n                    1\r\n                );\r\n                break;\r\n            case 'month':\r\n                time = startOfDate(this.year(), this.month(), 1);\r\n                break;\r\n            case 'week':\r\n                time = startOfDate(\r\n                    this.year(),\r\n                    this.month(),\r\n                    this.date() - this.weekday()\r\n                );\r\n                break;\r\n            case 'isoWeek':\r\n                time = startOfDate(\r\n                    this.year(),\r\n                    this.month(),\r\n                    this.date() - (this.isoWeekday() - 1)\r\n                );\r\n                break;\r\n            case 'day':\r\n            case 'date':\r\n                time = startOfDate(this.year(), this.month(), this.date());\r\n                break;\r\n            case 'hour':\r\n                time = this._d.valueOf();\r\n                time -= mod$1(\r\n                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\r\n                    MS_PER_HOUR\r\n                );\r\n                break;\r\n            case 'minute':\r\n                time = this._d.valueOf();\r\n                time -= mod$1(time, MS_PER_MINUTE);\r\n                break;\r\n            case 'second':\r\n                time = this._d.valueOf();\r\n                time -= mod$1(time, MS_PER_SECOND);\r\n                break;\r\n        }\r\n\r\n        this._d.setTime(time);\r\n        hooks.updateOffset(this, true);\r\n        return this;\r\n    }\r\n\r\n    function endOf(units) {\r\n        var time, startOfDate;\r\n        units = normalizeUnits(units);\r\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\r\n            return this;\r\n        }\r\n\r\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\r\n\r\n        switch (units) {\r\n            case 'year':\r\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\r\n                break;\r\n            case 'quarter':\r\n                time =\r\n                    startOfDate(\r\n                        this.year(),\r\n                        this.month() - (this.month() % 3) + 3,\r\n                        1\r\n                    ) - 1;\r\n                break;\r\n            case 'month':\r\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\r\n                break;\r\n            case 'week':\r\n                time =\r\n                    startOfDate(\r\n                        this.year(),\r\n                        this.month(),\r\n                        this.date() - this.weekday() + 7\r\n                    ) - 1;\r\n                break;\r\n            case 'isoWeek':\r\n                time =\r\n                    startOfDate(\r\n                        this.year(),\r\n                        this.month(),\r\n                        this.date() - (this.isoWeekday() - 1) + 7\r\n                    ) - 1;\r\n                break;\r\n            case 'day':\r\n            case 'date':\r\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\r\n                break;\r\n            case 'hour':\r\n                time = this._d.valueOf();\r\n                time +=\r\n                    MS_PER_HOUR -\r\n                    mod$1(\r\n                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\r\n                        MS_PER_HOUR\r\n                    ) -\r\n                    1;\r\n                break;\r\n            case 'minute':\r\n                time = this._d.valueOf();\r\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\r\n                break;\r\n            case 'second':\r\n                time = this._d.valueOf();\r\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\r\n                break;\r\n        }\r\n\r\n        this._d.setTime(time);\r\n        hooks.updateOffset(this, true);\r\n        return this;\r\n    }\r\n\r\n    function valueOf() {\r\n        return this._d.valueOf() - (this._offset || 0) * 60000;\r\n    }\r\n\r\n    function unix() {\r\n        return Math.floor(this.valueOf() / 1000);\r\n    }\r\n\r\n    function toDate() {\r\n        return new Date(this.valueOf());\r\n    }\r\n\r\n    function toArray() {\r\n        var m = this;\r\n        return [\r\n            m.year(),\r\n            m.month(),\r\n            m.date(),\r\n            m.hour(),\r\n            m.minute(),\r\n            m.second(),\r\n            m.millisecond(),\r\n        ];\r\n    }\r\n\r\n    function toObject() {\r\n        var m = this;\r\n        return {\r\n            years: m.year(),\r\n            months: m.month(),\r\n            date: m.date(),\r\n            hours: m.hours(),\r\n            minutes: m.minutes(),\r\n            seconds: m.seconds(),\r\n            milliseconds: m.milliseconds(),\r\n        };\r\n    }\r\n\r\n    function toJSON() {\r\n        // new Date(NaN).toJSON() === null\r\n        return this.isValid() ? this.toISOString() : null;\r\n    }\r\n\r\n    function isValid$2() {\r\n        return isValid(this);\r\n    }\r\n\r\n    function parsingFlags() {\r\n        return extend({}, getParsingFlags(this));\r\n    }\r\n\r\n    function invalidAt() {\r\n        return getParsingFlags(this).overflow;\r\n    }\r\n\r\n    function creationData() {\r\n        return {\r\n            input: this._i,\r\n            format: this._f,\r\n            locale: this._locale,\r\n            isUTC: this._isUTC,\r\n            strict: this._strict,\r\n        };\r\n    }\r\n\r\n    addFormatToken('N', 0, 0, 'eraAbbr');\r\n    addFormatToken('NN', 0, 0, 'eraAbbr');\r\n    addFormatToken('NNN', 0, 0, 'eraAbbr');\r\n    addFormatToken('NNNN', 0, 0, 'eraName');\r\n    addFormatToken('NNNNN', 0, 0, 'eraNarrow');\r\n\r\n    addFormatToken('y', ['y', 1], 'yo', 'eraYear');\r\n    addFormatToken('y', ['yy', 2], 0, 'eraYear');\r\n    addFormatToken('y', ['yyy', 3], 0, 'eraYear');\r\n    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\r\n\r\n    addRegexToken('N', matchEraAbbr);\r\n    addRegexToken('NN', matchEraAbbr);\r\n    addRegexToken('NNN', matchEraAbbr);\r\n    addRegexToken('NNNN', matchEraName);\r\n    addRegexToken('NNNNN', matchEraNarrow);\r\n\r\n    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (\r\n        input,\r\n        array,\r\n        config,\r\n        token\r\n    ) {\r\n        var era = config._locale.erasParse(input, token, config._strict);\r\n        if (era) {\r\n            getParsingFlags(config).era = era;\r\n        } else {\r\n            getParsingFlags(config).invalidEra = input;\r\n        }\r\n    });\r\n\r\n    addRegexToken('y', matchUnsigned);\r\n    addRegexToken('yy', matchUnsigned);\r\n    addRegexToken('yyy', matchUnsigned);\r\n    addRegexToken('yyyy', matchUnsigned);\r\n    addRegexToken('yo', matchEraYearOrdinal);\r\n\r\n    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\r\n    addParseToken(['yo'], function (input, array, config, token) {\r\n        var match;\r\n        if (config._locale._eraYearOrdinalRegex) {\r\n            match = input.match(config._locale._eraYearOrdinalRegex);\r\n        }\r\n\r\n        if (config._locale.eraYearOrdinalParse) {\r\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\r\n        } else {\r\n            array[YEAR] = parseInt(input, 10);\r\n        }\r\n    });\r\n\r\n    function localeEras(m, format) {\r\n        var i,\r\n            l,\r\n            date,\r\n            eras = this._eras || getLocale('en')._eras;\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            switch (typeof eras[i].since) {\r\n                case 'string':\r\n                    // truncate time\r\n                    date = hooks(eras[i].since).startOf('day');\r\n                    eras[i].since = date.valueOf();\r\n                    break;\r\n            }\r\n\r\n            switch (typeof eras[i].until) {\r\n                case 'undefined':\r\n                    eras[i].until = +Infinity;\r\n                    break;\r\n                case 'string':\r\n                    // truncate time\r\n                    date = hooks(eras[i].until).startOf('day').valueOf();\r\n                    eras[i].until = date.valueOf();\r\n                    break;\r\n            }\r\n        }\r\n        return eras;\r\n    }\r\n\r\n    function localeErasParse(eraName, format, strict) {\r\n        var i,\r\n            l,\r\n            eras = this.eras(),\r\n            name,\r\n            abbr,\r\n            narrow;\r\n        eraName = eraName.toUpperCase();\r\n\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            name = eras[i].name.toUpperCase();\r\n            abbr = eras[i].abbr.toUpperCase();\r\n            narrow = eras[i].narrow.toUpperCase();\r\n\r\n            if (strict) {\r\n                switch (format) {\r\n                    case 'N':\r\n                    case 'NN':\r\n                    case 'NNN':\r\n                        if (abbr === eraName) {\r\n                            return eras[i];\r\n                        }\r\n                        break;\r\n\r\n                    case 'NNNN':\r\n                        if (name === eraName) {\r\n                            return eras[i];\r\n                        }\r\n                        break;\r\n\r\n                    case 'NNNNN':\r\n                        if (narrow === eraName) {\r\n                            return eras[i];\r\n                        }\r\n                        break;\r\n                }\r\n            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\r\n                return eras[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function localeErasConvertYear(era, year) {\r\n        var dir = era.since <= era.until ? +1 : -1;\r\n        if (year === undefined) {\r\n            return hooks(era.since).year();\r\n        } else {\r\n            return hooks(era.since).year() + (year - era.offset) * dir;\r\n        }\r\n    }\r\n\r\n    function getEraName() {\r\n        var i,\r\n            l,\r\n            val,\r\n            eras = this.localeData().eras();\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            // truncate time\r\n            val = this.clone().startOf('day').valueOf();\r\n\r\n            if (eras[i].since <= val && val <= eras[i].until) {\r\n                return eras[i].name;\r\n            }\r\n            if (eras[i].until <= val && val <= eras[i].since) {\r\n                return eras[i].name;\r\n            }\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    function getEraNarrow() {\r\n        var i,\r\n            l,\r\n            val,\r\n            eras = this.localeData().eras();\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            // truncate time\r\n            val = this.clone().startOf('day').valueOf();\r\n\r\n            if (eras[i].since <= val && val <= eras[i].until) {\r\n                return eras[i].narrow;\r\n            }\r\n            if (eras[i].until <= val && val <= eras[i].since) {\r\n                return eras[i].narrow;\r\n            }\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    function getEraAbbr() {\r\n        var i,\r\n            l,\r\n            val,\r\n            eras = this.localeData().eras();\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            // truncate time\r\n            val = this.clone().startOf('day').valueOf();\r\n\r\n            if (eras[i].since <= val && val <= eras[i].until) {\r\n                return eras[i].abbr;\r\n            }\r\n            if (eras[i].until <= val && val <= eras[i].since) {\r\n                return eras[i].abbr;\r\n            }\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    function getEraYear() {\r\n        var i,\r\n            l,\r\n            dir,\r\n            val,\r\n            eras = this.localeData().eras();\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\r\n\r\n            // truncate time\r\n            val = this.clone().startOf('day').valueOf();\r\n\r\n            if (\r\n                (eras[i].since <= val && val <= eras[i].until) ||\r\n                (eras[i].until <= val && val <= eras[i].since)\r\n            ) {\r\n                return (\r\n                    (this.year() - hooks(eras[i].since).year()) * dir +\r\n                    eras[i].offset\r\n                );\r\n            }\r\n        }\r\n\r\n        return this.year();\r\n    }\r\n\r\n    function erasNameRegex(isStrict) {\r\n        if (!hasOwnProp(this, '_erasNameRegex')) {\r\n            computeErasParse.call(this);\r\n        }\r\n        return isStrict ? this._erasNameRegex : this._erasRegex;\r\n    }\r\n\r\n    function erasAbbrRegex(isStrict) {\r\n        if (!hasOwnProp(this, '_erasAbbrRegex')) {\r\n            computeErasParse.call(this);\r\n        }\r\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\r\n    }\r\n\r\n    function erasNarrowRegex(isStrict) {\r\n        if (!hasOwnProp(this, '_erasNarrowRegex')) {\r\n            computeErasParse.call(this);\r\n        }\r\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\r\n    }\r\n\r\n    function matchEraAbbr(isStrict, locale) {\r\n        return locale.erasAbbrRegex(isStrict);\r\n    }\r\n\r\n    function matchEraName(isStrict, locale) {\r\n        return locale.erasNameRegex(isStrict);\r\n    }\r\n\r\n    function matchEraNarrow(isStrict, locale) {\r\n        return locale.erasNarrowRegex(isStrict);\r\n    }\r\n\r\n    function matchEraYearOrdinal(isStrict, locale) {\r\n        return locale._eraYearOrdinalRegex || matchUnsigned;\r\n    }\r\n\r\n    function computeErasParse() {\r\n        var abbrPieces = [],\r\n            namePieces = [],\r\n            narrowPieces = [],\r\n            mixedPieces = [],\r\n            i,\r\n            l,\r\n            eras = this.eras();\r\n\r\n        for (i = 0, l = eras.length; i < l; ++i) {\r\n            namePieces.push(regexEscape(eras[i].name));\r\n            abbrPieces.push(regexEscape(eras[i].abbr));\r\n            narrowPieces.push(regexEscape(eras[i].narrow));\r\n\r\n            mixedPieces.push(regexEscape(eras[i].name));\r\n            mixedPieces.push(regexEscape(eras[i].abbr));\r\n            mixedPieces.push(regexEscape(eras[i].narrow));\r\n        }\r\n\r\n        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\r\n        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\r\n        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\r\n        this._erasNarrowRegex = new RegExp(\r\n            '^(' + narrowPieces.join('|') + ')',\r\n            'i'\r\n        );\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken(0, ['gg', 2], 0, function () {\r\n        return this.weekYear() % 100;\r\n    });\r\n\r\n    addFormatToken(0, ['GG', 2], 0, function () {\r\n        return this.isoWeekYear() % 100;\r\n    });\r\n\r\n    function addWeekYearFormatToken(token, getter) {\r\n        addFormatToken(0, [token, token.length], 0, getter);\r\n    }\r\n\r\n    addWeekYearFormatToken('gggg', 'weekYear');\r\n    addWeekYearFormatToken('ggggg', 'weekYear');\r\n    addWeekYearFormatToken('GGGG', 'isoWeekYear');\r\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('weekYear', 'gg');\r\n    addUnitAlias('isoWeekYear', 'GG');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('weekYear', 1);\r\n    addUnitPriority('isoWeekYear', 1);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('G', matchSigned);\r\n    addRegexToken('g', matchSigned);\r\n    addRegexToken('GG', match1to2, match2);\r\n    addRegexToken('gg', match1to2, match2);\r\n    addRegexToken('GGGG', match1to4, match4);\r\n    addRegexToken('gggg', match1to4, match4);\r\n    addRegexToken('GGGGG', match1to6, match6);\r\n    addRegexToken('ggggg', match1to6, match6);\r\n\r\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (\r\n        input,\r\n        week,\r\n        config,\r\n        token\r\n    ) {\r\n        week[token.substr(0, 2)] = toInt(input);\r\n    });\r\n\r\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\r\n        week[token] = hooks.parseTwoDigitYear(input);\r\n    });\r\n\r\n    // MOMENTS\r\n\r\n    function getSetWeekYear(input) {\r\n        return getSetWeekYearHelper.call(\r\n            this,\r\n            input,\r\n            this.week(),\r\n            this.weekday(),\r\n            this.localeData()._week.dow,\r\n            this.localeData()._week.doy\r\n        );\r\n    }\r\n\r\n    function getSetISOWeekYear(input) {\r\n        return getSetWeekYearHelper.call(\r\n            this,\r\n            input,\r\n            this.isoWeek(),\r\n            this.isoWeekday(),\r\n            1,\r\n            4\r\n        );\r\n    }\r\n\r\n    function getISOWeeksInYear() {\r\n        return weeksInYear(this.year(), 1, 4);\r\n    }\r\n\r\n    function getISOWeeksInISOWeekYear() {\r\n        return weeksInYear(this.isoWeekYear(), 1, 4);\r\n    }\r\n\r\n    function getWeeksInYear() {\r\n        var weekInfo = this.localeData()._week;\r\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\r\n    }\r\n\r\n    function getWeeksInWeekYear() {\r\n        var weekInfo = this.localeData()._week;\r\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\r\n    }\r\n\r\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\r\n        var weeksTarget;\r\n        if (input == null) {\r\n            return weekOfYear(this, dow, doy).year;\r\n        } else {\r\n            weeksTarget = weeksInYear(input, dow, doy);\r\n            if (week > weeksTarget) {\r\n                week = weeksTarget;\r\n            }\r\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\r\n        }\r\n    }\r\n\r\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\r\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\r\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\r\n\r\n        this.year(date.getUTCFullYear());\r\n        this.month(date.getUTCMonth());\r\n        this.date(date.getUTCDate());\r\n        return this;\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('Q', 0, 'Qo', 'quarter');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('quarter', 'Q');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('quarter', 7);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('Q', match1);\r\n    addParseToken('Q', function (input, array) {\r\n        array[MONTH] = (toInt(input) - 1) * 3;\r\n    });\r\n\r\n    // MOMENTS\r\n\r\n    function getSetQuarter(input) {\r\n        return input == null\r\n            ? Math.ceil((this.month() + 1) / 3)\r\n            : this.month((input - 1) * 3 + (this.month() % 3));\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('date', 'D');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('date', 9);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('D', match1to2);\r\n    addRegexToken('DD', match1to2, match2);\r\n    addRegexToken('Do', function (isStrict, locale) {\r\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\r\n        return isStrict\r\n            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse\r\n            : locale._dayOfMonthOrdinalParseLenient;\r\n    });\r\n\r\n    addParseToken(['D', 'DD'], DATE);\r\n    addParseToken('Do', function (input, array) {\r\n        array[DATE] = toInt(input.match(match1to2)[0]);\r\n    });\r\n\r\n    // MOMENTS\r\n\r\n    var getSetDayOfMonth = makeGetSet('Date', true);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('dayOfYear', 'DDD');\r\n\r\n    // PRIORITY\r\n    addUnitPriority('dayOfYear', 4);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('DDD', match1to3);\r\n    addRegexToken('DDDD', match3);\r\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\r\n        config._dayOfYear = toInt(input);\r\n    });\r\n\r\n    // HELPERS\r\n\r\n    // MOMENTS\r\n\r\n    function getSetDayOfYear(input) {\r\n        var dayOfYear =\r\n            Math.round(\r\n                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5\r\n            ) + 1;\r\n        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\r\n    }\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('m', ['mm', 2], 0, 'minute');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('minute', 'm');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('minute', 14);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('m', match1to2);\r\n    addRegexToken('mm', match1to2, match2);\r\n    addParseToken(['m', 'mm'], MINUTE);\r\n\r\n    // MOMENTS\r\n\r\n    var getSetMinute = makeGetSet('Minutes', false);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('s', ['ss', 2], 0, 'second');\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('second', 's');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('second', 15);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('s', match1to2);\r\n    addRegexToken('ss', match1to2, match2);\r\n    addParseToken(['s', 'ss'], SECOND);\r\n\r\n    // MOMENTS\r\n\r\n    var getSetSecond = makeGetSet('Seconds', false);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('S', 0, 0, function () {\r\n        return ~~(this.millisecond() / 100);\r\n    });\r\n\r\n    addFormatToken(0, ['SS', 2], 0, function () {\r\n        return ~~(this.millisecond() / 10);\r\n    });\r\n\r\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\r\n    addFormatToken(0, ['SSSS', 4], 0, function () {\r\n        return this.millisecond() * 10;\r\n    });\r\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\r\n        return this.millisecond() * 100;\r\n    });\r\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\r\n        return this.millisecond() * 1000;\r\n    });\r\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\r\n        return this.millisecond() * 10000;\r\n    });\r\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\r\n        return this.millisecond() * 100000;\r\n    });\r\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\r\n        return this.millisecond() * 1000000;\r\n    });\r\n\r\n    // ALIASES\r\n\r\n    addUnitAlias('millisecond', 'ms');\r\n\r\n    // PRIORITY\r\n\r\n    addUnitPriority('millisecond', 16);\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('S', match1to3, match1);\r\n    addRegexToken('SS', match1to3, match2);\r\n    addRegexToken('SSS', match1to3, match3);\r\n\r\n    var token, getSetMillisecond;\r\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\r\n        addRegexToken(token, matchUnsigned);\r\n    }\r\n\r\n    function parseMs(input, array) {\r\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\r\n    }\r\n\r\n    for (token = 'S'; token.length <= 9; token += 'S') {\r\n        addParseToken(token, parseMs);\r\n    }\r\n\r\n    getSetMillisecond = makeGetSet('Milliseconds', false);\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('z', 0, 0, 'zoneAbbr');\r\n    addFormatToken('zz', 0, 0, 'zoneName');\r\n\r\n    // MOMENTS\r\n\r\n    function getZoneAbbr() {\r\n        return this._isUTC ? 'UTC' : '';\r\n    }\r\n\r\n    function getZoneName() {\r\n        return this._isUTC ? 'Coordinated Universal Time' : '';\r\n    }\r\n\r\n    var proto = Moment.prototype;\r\n\r\n    proto.add = add;\r\n    proto.calendar = calendar$1;\r\n    proto.clone = clone;\r\n    proto.diff = diff;\r\n    proto.endOf = endOf;\r\n    proto.format = format;\r\n    proto.from = from;\r\n    proto.fromNow = fromNow;\r\n    proto.to = to;\r\n    proto.toNow = toNow;\r\n    proto.get = stringGet;\r\n    proto.invalidAt = invalidAt;\r\n    proto.isAfter = isAfter;\r\n    proto.isBefore = isBefore;\r\n    proto.isBetween = isBetween;\r\n    proto.isSame = isSame;\r\n    proto.isSameOrAfter = isSameOrAfter;\r\n    proto.isSameOrBefore = isSameOrBefore;\r\n    proto.isValid = isValid$2;\r\n    proto.lang = lang;\r\n    proto.locale = locale;\r\n    proto.localeData = localeData;\r\n    proto.max = prototypeMax;\r\n    proto.min = prototypeMin;\r\n    proto.parsingFlags = parsingFlags;\r\n    proto.set = stringSet;\r\n    proto.startOf = startOf;\r\n    proto.subtract = subtract;\r\n    proto.toArray = toArray;\r\n    proto.toObject = toObject;\r\n    proto.toDate = toDate;\r\n    proto.toISOString = toISOString;\r\n    proto.inspect = inspect;\r\n    if (typeof Symbol !== 'undefined' && Symbol.for != null) {\r\n        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {\r\n            return 'Moment<' + this.format() + '>';\r\n        };\r\n    }\r\n    proto.toJSON = toJSON;\r\n    proto.toString = toString;\r\n    proto.unix = unix;\r\n    proto.valueOf = valueOf;\r\n    proto.creationData = creationData;\r\n    proto.eraName = getEraName;\r\n    proto.eraNarrow = getEraNarrow;\r\n    proto.eraAbbr = getEraAbbr;\r\n    proto.eraYear = getEraYear;\r\n    proto.year = getSetYear;\r\n    proto.isLeapYear = getIsLeapYear;\r\n    proto.weekYear = getSetWeekYear;\r\n    proto.isoWeekYear = getSetISOWeekYear;\r\n    proto.quarter = proto.quarters = getSetQuarter;\r\n    proto.month = getSetMonth;\r\n    proto.daysInMonth = getDaysInMonth;\r\n    proto.week = proto.weeks = getSetWeek;\r\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\r\n    proto.weeksInYear = getWeeksInYear;\r\n    proto.weeksInWeekYear = getWeeksInWeekYear;\r\n    proto.isoWeeksInYear = getISOWeeksInYear;\r\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\r\n    proto.date = getSetDayOfMonth;\r\n    proto.day = proto.days = getSetDayOfWeek;\r\n    proto.weekday = getSetLocaleDayOfWeek;\r\n    proto.isoWeekday = getSetISODayOfWeek;\r\n    proto.dayOfYear = getSetDayOfYear;\r\n    proto.hour = proto.hours = getSetHour;\r\n    proto.minute = proto.minutes = getSetMinute;\r\n    proto.second = proto.seconds = getSetSecond;\r\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\r\n    proto.utcOffset = getSetOffset;\r\n    proto.utc = setOffsetToUTC;\r\n    proto.local = setOffsetToLocal;\r\n    proto.parseZone = setOffsetToParsedOffset;\r\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\r\n    proto.isDST = isDaylightSavingTime;\r\n    proto.isLocal = isLocal;\r\n    proto.isUtcOffset = isUtcOffset;\r\n    proto.isUtc = isUtc;\r\n    proto.isUTC = isUtc;\r\n    proto.zoneAbbr = getZoneAbbr;\r\n    proto.zoneName = getZoneName;\r\n    proto.dates = deprecate(\r\n        'dates accessor is deprecated. Use date instead.',\r\n        getSetDayOfMonth\r\n    );\r\n    proto.months = deprecate(\r\n        'months accessor is deprecated. Use month instead',\r\n        getSetMonth\r\n    );\r\n    proto.years = deprecate(\r\n        'years accessor is deprecated. Use year instead',\r\n        getSetYear\r\n    );\r\n    proto.zone = deprecate(\r\n        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',\r\n        getSetZone\r\n    );\r\n    proto.isDSTShifted = deprecate(\r\n        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',\r\n        isDaylightSavingTimeShifted\r\n    );\r\n\r\n    function createUnix(input) {\r\n        return createLocal(input * 1000);\r\n    }\r\n\r\n    function createInZone() {\r\n        return createLocal.apply(null, arguments).parseZone();\r\n    }\r\n\r\n    function preParsePostFormat(string) {\r\n        return string;\r\n    }\r\n\r\n    var proto$1 = Locale.prototype;\r\n\r\n    proto$1.calendar = calendar;\r\n    proto$1.longDateFormat = longDateFormat;\r\n    proto$1.invalidDate = invalidDate;\r\n    proto$1.ordinal = ordinal;\r\n    proto$1.preparse = preParsePostFormat;\r\n    proto$1.postformat = preParsePostFormat;\r\n    proto$1.relativeTime = relativeTime;\r\n    proto$1.pastFuture = pastFuture;\r\n    proto$1.set = set;\r\n    proto$1.eras = localeEras;\r\n    proto$1.erasParse = localeErasParse;\r\n    proto$1.erasConvertYear = localeErasConvertYear;\r\n    proto$1.erasAbbrRegex = erasAbbrRegex;\r\n    proto$1.erasNameRegex = erasNameRegex;\r\n    proto$1.erasNarrowRegex = erasNarrowRegex;\r\n\r\n    proto$1.months = localeMonths;\r\n    proto$1.monthsShort = localeMonthsShort;\r\n    proto$1.monthsParse = localeMonthsParse;\r\n    proto$1.monthsRegex = monthsRegex;\r\n    proto$1.monthsShortRegex = monthsShortRegex;\r\n    proto$1.week = localeWeek;\r\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\r\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\r\n\r\n    proto$1.weekdays = localeWeekdays;\r\n    proto$1.weekdaysMin = localeWeekdaysMin;\r\n    proto$1.weekdaysShort = localeWeekdaysShort;\r\n    proto$1.weekdaysParse = localeWeekdaysParse;\r\n\r\n    proto$1.weekdaysRegex = weekdaysRegex;\r\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\r\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\r\n\r\n    proto$1.isPM = localeIsPM;\r\n    proto$1.meridiem = localeMeridiem;\r\n\r\n    function get$1(format, index, field, setter) {\r\n        var locale = getLocale(),\r\n            utc = createUTC().set(setter, index);\r\n        return locale[field](utc, format);\r\n    }\r\n\r\n    function listMonthsImpl(format, index, field) {\r\n        if (isNumber(format)) {\r\n            index = format;\r\n            format = undefined;\r\n        }\r\n\r\n        format = format || '';\r\n\r\n        if (index != null) {\r\n            return get$1(format, index, field, 'month');\r\n        }\r\n\r\n        var i,\r\n            out = [];\r\n        for (i = 0; i < 12; i++) {\r\n            out[i] = get$1(format, i, field, 'month');\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // ()\r\n    // (5)\r\n    // (fmt, 5)\r\n    // (fmt)\r\n    // (true)\r\n    // (true, 5)\r\n    // (true, fmt, 5)\r\n    // (true, fmt)\r\n    function listWeekdaysImpl(localeSorted, format, index, field) {\r\n        if (typeof localeSorted === 'boolean') {\r\n            if (isNumber(format)) {\r\n                index = format;\r\n                format = undefined;\r\n            }\r\n\r\n            format = format || '';\r\n        } else {\r\n            format = localeSorted;\r\n            index = format;\r\n            localeSorted = false;\r\n\r\n            if (isNumber(format)) {\r\n                index = format;\r\n                format = undefined;\r\n            }\r\n\r\n            format = format || '';\r\n        }\r\n\r\n        var locale = getLocale(),\r\n            shift = localeSorted ? locale._week.dow : 0,\r\n            i,\r\n            out = [];\r\n\r\n        if (index != null) {\r\n            return get$1(format, (index + shift) % 7, field, 'day');\r\n        }\r\n\r\n        for (i = 0; i < 7; i++) {\r\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function listMonths(format, index) {\r\n        return listMonthsImpl(format, index, 'months');\r\n    }\r\n\r\n    function listMonthsShort(format, index) {\r\n        return listMonthsImpl(format, index, 'monthsShort');\r\n    }\r\n\r\n    function listWeekdays(localeSorted, format, index) {\r\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\r\n    }\r\n\r\n    function listWeekdaysShort(localeSorted, format, index) {\r\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\r\n    }\r\n\r\n    function listWeekdaysMin(localeSorted, format, index) {\r\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\r\n    }\r\n\r\n    getSetGlobalLocale('en', {\r\n        eras: [\r\n            {\r\n                since: '0001-01-01',\r\n                until: +Infinity,\r\n                offset: 1,\r\n                name: 'Anno Domini',\r\n                narrow: 'AD',\r\n                abbr: 'AD',\r\n            },\r\n            {\r\n                since: '0000-12-31',\r\n                until: -Infinity,\r\n                offset: 1,\r\n                name: 'Before Christ',\r\n                narrow: 'BC',\r\n                abbr: 'BC',\r\n            },\r\n        ],\r\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\r\n        ordinal: function (number) {\r\n            var b = number % 10,\r\n                output =\r\n                    toInt((number % 100) / 10) === 1\r\n                        ? 'th'\r\n                        : b === 1\r\n                        ? 'st'\r\n                        : b === 2\r\n                        ? 'nd'\r\n                        : b === 3\r\n                        ? 'rd'\r\n                        : 'th';\r\n            return number + output;\r\n        },\r\n    });\r\n\r\n    // Side effect imports\r\n\r\n    hooks.lang = deprecate(\r\n        'moment.lang is deprecated. Use moment.locale instead.',\r\n        getSetGlobalLocale\r\n    );\r\n    hooks.langData = deprecate(\r\n        'moment.langData is deprecated. Use moment.localeData instead.',\r\n        getLocale\r\n    );\r\n\r\n    var mathAbs = Math.abs;\r\n\r\n    function abs() {\r\n        var data = this._data;\r\n\r\n        this._milliseconds = mathAbs(this._milliseconds);\r\n        this._days = mathAbs(this._days);\r\n        this._months = mathAbs(this._months);\r\n\r\n        data.milliseconds = mathAbs(data.milliseconds);\r\n        data.seconds = mathAbs(data.seconds);\r\n        data.minutes = mathAbs(data.minutes);\r\n        data.hours = mathAbs(data.hours);\r\n        data.months = mathAbs(data.months);\r\n        data.years = mathAbs(data.years);\r\n\r\n        return this;\r\n    }\r\n\r\n    function addSubtract$1(duration, input, value, direction) {\r\n        var other = createDuration(input, value);\r\n\r\n        duration._milliseconds += direction * other._milliseconds;\r\n        duration._days += direction * other._days;\r\n        duration._months += direction * other._months;\r\n\r\n        return duration._bubble();\r\n    }\r\n\r\n    // supports only 2.0-style add(1, 's') or add(duration)\r\n    function add$1(input, value) {\r\n        return addSubtract$1(this, input, value, 1);\r\n    }\r\n\r\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\r\n    function subtract$1(input, value) {\r\n        return addSubtract$1(this, input, value, -1);\r\n    }\r\n\r\n    function absCeil(number) {\r\n        if (number < 0) {\r\n            return Math.floor(number);\r\n        } else {\r\n            return Math.ceil(number);\r\n        }\r\n    }\r\n\r\n    function bubble() {\r\n        var milliseconds = this._milliseconds,\r\n            days = this._days,\r\n            months = this._months,\r\n            data = this._data,\r\n            seconds,\r\n            minutes,\r\n            hours,\r\n            years,\r\n            monthsFromDays;\r\n\r\n        // if we have a mix of positive and negative values, bubble down first\r\n        // check: https://github.com/moment/moment/issues/2166\r\n        if (\r\n            !(\r\n                (milliseconds >= 0 && days >= 0 && months >= 0) ||\r\n                (milliseconds <= 0 && days <= 0 && months <= 0)\r\n            )\r\n        ) {\r\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\r\n            days = 0;\r\n            months = 0;\r\n        }\r\n\r\n        // The following code bubbles up values, see the tests for\r\n        // examples of what that means.\r\n        data.milliseconds = milliseconds % 1000;\r\n\r\n        seconds = absFloor(milliseconds / 1000);\r\n        data.seconds = seconds % 60;\r\n\r\n        minutes = absFloor(seconds / 60);\r\n        data.minutes = minutes % 60;\r\n\r\n        hours = absFloor(minutes / 60);\r\n        data.hours = hours % 24;\r\n\r\n        days += absFloor(hours / 24);\r\n\r\n        // convert days to months\r\n        monthsFromDays = absFloor(daysToMonths(days));\r\n        months += monthsFromDays;\r\n        days -= absCeil(monthsToDays(monthsFromDays));\r\n\r\n        // 12 months -> 1 year\r\n        years = absFloor(months / 12);\r\n        months %= 12;\r\n\r\n        data.days = days;\r\n        data.months = months;\r\n        data.years = years;\r\n\r\n        return this;\r\n    }\r\n\r\n    function daysToMonths(days) {\r\n        // 400 years have 146097 days (taking into account leap year rules)\r\n        // 400 years have 12 months === 4800\r\n        return (days * 4800) / 146097;\r\n    }\r\n\r\n    function monthsToDays(months) {\r\n        // the reverse of daysToMonths\r\n        return (months * 146097) / 4800;\r\n    }\r\n\r\n    function as(units) {\r\n        if (!this.isValid()) {\r\n            return NaN;\r\n        }\r\n        var days,\r\n            months,\r\n            milliseconds = this._milliseconds;\r\n\r\n        units = normalizeUnits(units);\r\n\r\n        if (units === 'month' || units === 'quarter' || units === 'year') {\r\n            days = this._days + milliseconds / 864e5;\r\n            months = this._months + daysToMonths(days);\r\n            switch (units) {\r\n                case 'month':\r\n                    return months;\r\n                case 'quarter':\r\n                    return months / 3;\r\n                case 'year':\r\n                    return months / 12;\r\n            }\r\n        } else {\r\n            // handle milliseconds separately because of floating point math errors (issue #1867)\r\n            days = this._days + Math.round(monthsToDays(this._months));\r\n            switch (units) {\r\n                case 'week':\r\n                    return days / 7 + milliseconds / 6048e5;\r\n                case 'day':\r\n                    return days + milliseconds / 864e5;\r\n                case 'hour':\r\n                    return days * 24 + milliseconds / 36e5;\r\n                case 'minute':\r\n                    return days * 1440 + milliseconds / 6e4;\r\n                case 'second':\r\n                    return days * 86400 + milliseconds / 1000;\r\n                // Math.floor prevents floating point math errors here\r\n                case 'millisecond':\r\n                    return Math.floor(days * 864e5) + milliseconds;\r\n                default:\r\n                    throw new Error('Unknown unit ' + units);\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: Use this.as('ms')?\r\n    function valueOf$1() {\r\n        if (!this.isValid()) {\r\n            return NaN;\r\n        }\r\n        return (\r\n            this._milliseconds +\r\n            this._days * 864e5 +\r\n            (this._months % 12) * 2592e6 +\r\n            toInt(this._months / 12) * 31536e6\r\n        );\r\n    }\r\n\r\n    function makeAs(alias) {\r\n        return function () {\r\n            return this.as(alias);\r\n        };\r\n    }\r\n\r\n    var asMilliseconds = makeAs('ms'),\r\n        asSeconds = makeAs('s'),\r\n        asMinutes = makeAs('m'),\r\n        asHours = makeAs('h'),\r\n        asDays = makeAs('d'),\r\n        asWeeks = makeAs('w'),\r\n        asMonths = makeAs('M'),\r\n        asQuarters = makeAs('Q'),\r\n        asYears = makeAs('y');\r\n\r\n    function clone$1() {\r\n        return createDuration(this);\r\n    }\r\n\r\n    function get$2(units) {\r\n        units = normalizeUnits(units);\r\n        return this.isValid() ? this[units + 's']() : NaN;\r\n    }\r\n\r\n    function makeGetter(name) {\r\n        return function () {\r\n            return this.isValid() ? this._data[name] : NaN;\r\n        };\r\n    }\r\n\r\n    var milliseconds = makeGetter('milliseconds'),\r\n        seconds = makeGetter('seconds'),\r\n        minutes = makeGetter('minutes'),\r\n        hours = makeGetter('hours'),\r\n        days = makeGetter('days'),\r\n        months = makeGetter('months'),\r\n        years = makeGetter('years');\r\n\r\n    function weeks() {\r\n        return absFloor(this.days() / 7);\r\n    }\r\n\r\n    var round = Math.round,\r\n        thresholds = {\r\n            ss: 44, // a few seconds to seconds\r\n            s: 45, // seconds to minute\r\n            m: 45, // minutes to hour\r\n            h: 22, // hours to day\r\n            d: 26, // days to month/week\r\n            w: null, // weeks to month\r\n            M: 11, // months to year\r\n        };\r\n\r\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\r\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\r\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\r\n    }\r\n\r\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\r\n        var duration = createDuration(posNegDuration).abs(),\r\n            seconds = round(duration.as('s')),\r\n            minutes = round(duration.as('m')),\r\n            hours = round(duration.as('h')),\r\n            days = round(duration.as('d')),\r\n            months = round(duration.as('M')),\r\n            weeks = round(duration.as('w')),\r\n            years = round(duration.as('y')),\r\n            a =\r\n                (seconds <= thresholds.ss && ['s', seconds]) ||\r\n                (seconds < thresholds.s && ['ss', seconds]) ||\r\n                (minutes <= 1 && ['m']) ||\r\n                (minutes < thresholds.m && ['mm', minutes]) ||\r\n                (hours <= 1 && ['h']) ||\r\n                (hours < thresholds.h && ['hh', hours]) ||\r\n                (days <= 1 && ['d']) ||\r\n                (days < thresholds.d && ['dd', days]);\r\n\r\n        if (thresholds.w != null) {\r\n            a =\r\n                a ||\r\n                (weeks <= 1 && ['w']) ||\r\n                (weeks < thresholds.w && ['ww', weeks]);\r\n        }\r\n        a = a ||\r\n            (months <= 1 && ['M']) ||\r\n            (months < thresholds.M && ['MM', months]) ||\r\n            (years <= 1 && ['y']) || ['yy', years];\r\n\r\n        a[2] = withoutSuffix;\r\n        a[3] = +posNegDuration > 0;\r\n        a[4] = locale;\r\n        return substituteTimeAgo.apply(null, a);\r\n    }\r\n\r\n    // This function allows you to set the rounding function for relative time strings\r\n    function getSetRelativeTimeRounding(roundingFunction) {\r\n        if (roundingFunction === undefined) {\r\n            return round;\r\n        }\r\n        if (typeof roundingFunction === 'function') {\r\n            round = roundingFunction;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // This function allows you to set a threshold for relative time strings\r\n    function getSetRelativeTimeThreshold(threshold, limit) {\r\n        if (thresholds[threshold] === undefined) {\r\n            return false;\r\n        }\r\n        if (limit === undefined) {\r\n            return thresholds[threshold];\r\n        }\r\n        thresholds[threshold] = limit;\r\n        if (threshold === 's') {\r\n            thresholds.ss = limit - 1;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function humanize(argWithSuffix, argThresholds) {\r\n        if (!this.isValid()) {\r\n            return this.localeData().invalidDate();\r\n        }\r\n\r\n        var withSuffix = false,\r\n            th = thresholds,\r\n            locale,\r\n            output;\r\n\r\n        if (typeof argWithSuffix === 'object') {\r\n            argThresholds = argWithSuffix;\r\n            argWithSuffix = false;\r\n        }\r\n        if (typeof argWithSuffix === 'boolean') {\r\n            withSuffix = argWithSuffix;\r\n        }\r\n        if (typeof argThresholds === 'object') {\r\n            th = Object.assign({}, thresholds, argThresholds);\r\n            if (argThresholds.s != null && argThresholds.ss == null) {\r\n                th.ss = argThresholds.s - 1;\r\n            }\r\n        }\r\n\r\n        locale = this.localeData();\r\n        output = relativeTime$1(this, !withSuffix, th, locale);\r\n\r\n        if (withSuffix) {\r\n            output = locale.pastFuture(+this, output);\r\n        }\r\n\r\n        return locale.postformat(output);\r\n    }\r\n\r\n    var abs$1 = Math.abs;\r\n\r\n    function sign(x) {\r\n        return (x > 0) - (x < 0) || +x;\r\n    }\r\n\r\n    function toISOString$1() {\r\n        // for ISO strings we do not use the normal bubbling rules:\r\n        //  * milliseconds bubble up until they become hours\r\n        //  * days do not bubble at all\r\n        //  * months bubble up until they become years\r\n        // This is because there is no context-free conversion between hours and days\r\n        // (think of clock changes)\r\n        // and also not between days and months (28-31 days per month)\r\n        if (!this.isValid()) {\r\n            return this.localeData().invalidDate();\r\n        }\r\n\r\n        var seconds = abs$1(this._milliseconds) / 1000,\r\n            days = abs$1(this._days),\r\n            months = abs$1(this._months),\r\n            minutes,\r\n            hours,\r\n            years,\r\n            s,\r\n            total = this.asSeconds(),\r\n            totalSign,\r\n            ymSign,\r\n            daysSign,\r\n            hmsSign;\r\n\r\n        if (!total) {\r\n            // this is the same as C#'s (Noda) and python (isodate)...\r\n            // but not other JS (goog.date)\r\n            return 'P0D';\r\n        }\r\n\r\n        // 3600 seconds -> 60 minutes -> 1 hour\r\n        minutes = absFloor(seconds / 60);\r\n        hours = absFloor(minutes / 60);\r\n        seconds %= 60;\r\n        minutes %= 60;\r\n\r\n        // 12 months -> 1 year\r\n        years = absFloor(months / 12);\r\n        months %= 12;\r\n\r\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\r\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\r\n\r\n        totalSign = total < 0 ? '-' : '';\r\n        ymSign = sign(this._months) !== sign(total) ? '-' : '';\r\n        daysSign = sign(this._days) !== sign(total) ? '-' : '';\r\n        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\r\n\r\n        return (\r\n            totalSign +\r\n            'P' +\r\n            (years ? ymSign + years + 'Y' : '') +\r\n            (months ? ymSign + months + 'M' : '') +\r\n            (days ? daysSign + days + 'D' : '') +\r\n            (hours || minutes || seconds ? 'T' : '') +\r\n            (hours ? hmsSign + hours + 'H' : '') +\r\n            (minutes ? hmsSign + minutes + 'M' : '') +\r\n            (seconds ? hmsSign + s + 'S' : '')\r\n        );\r\n    }\r\n\r\n    var proto$2 = Duration.prototype;\r\n\r\n    proto$2.isValid = isValid$1;\r\n    proto$2.abs = abs;\r\n    proto$2.add = add$1;\r\n    proto$2.subtract = subtract$1;\r\n    proto$2.as = as;\r\n    proto$2.asMilliseconds = asMilliseconds;\r\n    proto$2.asSeconds = asSeconds;\r\n    proto$2.asMinutes = asMinutes;\r\n    proto$2.asHours = asHours;\r\n    proto$2.asDays = asDays;\r\n    proto$2.asWeeks = asWeeks;\r\n    proto$2.asMonths = asMonths;\r\n    proto$2.asQuarters = asQuarters;\r\n    proto$2.asYears = asYears;\r\n    proto$2.valueOf = valueOf$1;\r\n    proto$2._bubble = bubble;\r\n    proto$2.clone = clone$1;\r\n    proto$2.get = get$2;\r\n    proto$2.milliseconds = milliseconds;\r\n    proto$2.seconds = seconds;\r\n    proto$2.minutes = minutes;\r\n    proto$2.hours = hours;\r\n    proto$2.days = days;\r\n    proto$2.weeks = weeks;\r\n    proto$2.months = months;\r\n    proto$2.years = years;\r\n    proto$2.humanize = humanize;\r\n    proto$2.toISOString = toISOString$1;\r\n    proto$2.toString = toISOString$1;\r\n    proto$2.toJSON = toISOString$1;\r\n    proto$2.locale = locale;\r\n    proto$2.localeData = localeData;\r\n\r\n    proto$2.toIsoString = deprecate(\r\n        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',\r\n        toISOString$1\r\n    );\r\n    proto$2.lang = lang;\r\n\r\n    // FORMATTING\r\n\r\n    addFormatToken('X', 0, 0, 'unix');\r\n    addFormatToken('x', 0, 0, 'valueOf');\r\n\r\n    // PARSING\r\n\r\n    addRegexToken('x', matchSigned);\r\n    addRegexToken('X', matchTimestamp);\r\n    addParseToken('X', function (input, array, config) {\r\n        config._d = new Date(parseFloat(input) * 1000);\r\n    });\r\n    addParseToken('x', function (input, array, config) {\r\n        config._d = new Date(toInt(input));\r\n    });\r\n\r\n    //! moment.js\r\n\r\n    hooks.version = '2.29.1';\r\n\r\n    setHookCallback(createLocal);\r\n\r\n    hooks.fn = proto;\r\n    hooks.min = min;\r\n    hooks.max = max;\r\n    hooks.now = now;\r\n    hooks.utc = createUTC;\r\n    hooks.unix = createUnix;\r\n    hooks.months = listMonths;\r\n    hooks.isDate = isDate;\r\n    hooks.locale = getSetGlobalLocale;\r\n    hooks.invalid = createInvalid;\r\n    hooks.duration = createDuration;\r\n    hooks.isMoment = isMoment;\r\n    hooks.weekdays = listWeekdays;\r\n    hooks.parseZone = createInZone;\r\n    hooks.localeData = getLocale;\r\n    hooks.isDuration = isDuration;\r\n    hooks.monthsShort = listMonthsShort;\r\n    hooks.weekdaysMin = listWeekdaysMin;\r\n    hooks.defineLocale = defineLocale;\r\n    hooks.updateLocale = updateLocale;\r\n    hooks.locales = listLocales;\r\n    hooks.weekdaysShort = listWeekdaysShort;\r\n    hooks.normalizeUnits = normalizeUnits;\r\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\r\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\r\n    hooks.calendarFormat = getCalendarFormat;\r\n    hooks.prototype = proto;\r\n\r\n    // currently HTML5 input type only supports 24-hour formats\r\n    hooks.HTML5_FMT = {\r\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type=\"datetime-local\" />\r\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type=\"datetime-local\" step=\"1\" />\r\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type=\"datetime-local\" step=\"0.001\" />\r\n        DATE: 'YYYY-MM-DD', // <input type=\"date\" />\r\n        TIME: 'HH:mm', // <input type=\"time\" />\r\n        TIME_SECONDS: 'HH:mm:ss', // <input type=\"time\" step=\"1\" />\r\n        TIME_MS: 'HH:mm:ss.SSS', // <input type=\"time\" step=\"0.001\" />\r\n        WEEK: 'GGGG-[W]WW', // <input type=\"week\" />\r\n        MONTH: 'YYYY-MM', // <input type=\"month\" />\r\n    };\r\n\r\n    return hooks;\r\n\r\n})));\r\n","import { runTimer } from './timer';\n\nrunTimer();\n","/* eslint-disable import/prefer-default-export */\nimport * as moment from '../node_modules/moment/moment';\n\nconst timerInput = <HTMLInputElement>document.getElementById('timer-input');\nconst timerMoreBtn = document.getElementById('timer-more-btn');\nconst timerLessBtn = document.getElementById('timer-less-btn');\n\ntimerMoreBtn.onclick = () => {\n  if (!timerInput.value) {\n    timerInput.value = '0';\n  }\n  let inputTime = parseInt(timerInput.value, 10);\n  inputTime += 1;\n  timerInput.value = inputTime.toString();\n};\ntimerLessBtn.onclick = () => {\n  let inputTime = parseInt(timerInput.value, 10);\n  if (inputTime > 0) {\n    inputTime -= 1;\n    timerInput.value = inputTime.toString();\n  } else {\n    alert('Wanna go back in time? Good luck with that!');\n  }\n};\n\ntimerInput.oninput = () => {\n  if (Number.isNaN(parseInt(timerInput.value, 10))) {\n    alert('What kind of time is that?');\n    timerInput.value = '0';\n  }\n};\n\nexport function runTimer() {\n  let usersTime;\n  const start = document.getElementById('start');\n  start.onclick = () => {\n    usersTime = timerInput.value;\n    const time = moment({ minute: parseInt(usersTime, 10), second: 0 });\n    const timerText = document.getElementById('timer-text');\n    timerText.innerHTML = ':';\n    const timerMenu = document.getElementById('timer-menu');\n    timerMenu.style.display = 'none';\n    start.style.display = 'none';\n    const timerOutput = document.createElement('div');\n    timerOutput.classList.add('timer-output');\n    const timer = document.getElementById('timer');\n    timer.appendChild(timerOutput);\n\n    timerOutput.innerHTML = time.format('mm:ss');\n    const timing = setInterval(() => {\n      const newTime = time.subtract(1, 'seconds');\n      timerOutput.innerHTML = newTime.format('mm:ss');\n    }, 1000);\n    setTimeout(() => {\n      clearInterval(timing);\n    }, parseInt(usersTime, 10) * 1000 * 60);\n  };\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsInNyYy9tYWluLnRzIiwic3JjL3RpbWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdGlMQSxJQUFBLFVBQUEsUUFBQSxTQUFBLENBQUE7QUFFQSxRQUFBLFFBQUE7Ozs7Ozs7QUNGQTtBQUNBLElBQUEsU0FBQSxRQUFBLCtCQUFBLENBQUE7QUFFQSxJQUFNLGFBQStCLFNBQVMsY0FBVCxDQUF3QixhQUF4QixDQUFyQztBQUNBLElBQU0sZUFBZSxTQUFTLGNBQVQsQ0FBd0IsZ0JBQXhCLENBQXJCO0FBQ0EsSUFBTSxlQUFlLFNBQVMsY0FBVCxDQUF3QixnQkFBeEIsQ0FBckI7QUFFQSxhQUFhLE9BQWIsR0FBdUIsWUFBSztBQUMxQixRQUFJLENBQUMsV0FBVyxLQUFoQixFQUF1QjtBQUNyQixtQkFBVyxLQUFYLEdBQW1CLEdBQW5CO0FBQ0Q7QUFDRCxRQUFJLFlBQVksU0FBUyxXQUFXLEtBQXBCLEVBQTJCLEVBQTNCLENBQWhCO0FBQ0EsaUJBQWEsQ0FBYjtBQUNBLGVBQVcsS0FBWCxHQUFtQixVQUFVLFFBQVYsRUFBbkI7QUFDRCxDQVBEO0FBUUEsYUFBYSxPQUFiLEdBQXVCLFlBQUs7QUFDMUIsUUFBSSxZQUFZLFNBQVMsV0FBVyxLQUFwQixFQUEyQixFQUEzQixDQUFoQjtBQUNBLFFBQUksWUFBWSxDQUFoQixFQUFtQjtBQUNqQixxQkFBYSxDQUFiO0FBQ0EsbUJBQVcsS0FBWCxHQUFtQixVQUFVLFFBQVYsRUFBbkI7QUFDRCxLQUhELE1BR087QUFDTCxjQUFNLDZDQUFOO0FBQ0Q7QUFDRixDQVJEO0FBVUEsV0FBVyxPQUFYLEdBQXFCLFlBQUs7QUFDeEIsUUFBSSxPQUFPLEtBQVAsQ0FBYSxTQUFTLFdBQVcsS0FBcEIsRUFBMkIsRUFBM0IsQ0FBYixDQUFKLEVBQWtEO0FBQ2hELGNBQU0sNEJBQU47QUFDQSxtQkFBVyxLQUFYLEdBQW1CLEdBQW5CO0FBQ0Q7QUFDRixDQUxEO0FBT0EsU0FBZ0IsUUFBaEIsR0FBd0I7QUFDdEIsUUFBSSxrQkFBSjtBQUNBLFFBQU0sUUFBUSxTQUFTLGNBQVQsQ0FBd0IsT0FBeEIsQ0FBZDtBQUNBLFVBQU0sT0FBTixHQUFnQixZQUFLO0FBQ25CLG9CQUFZLFdBQVcsS0FBdkI7QUFDQSxZQUFNLE9BQU8sT0FBTyxFQUFFLFFBQVEsU0FBUyxTQUFULEVBQW9CLEVBQXBCLENBQVYsRUFBbUMsUUFBUSxDQUEzQyxFQUFQLENBQWI7QUFDQSxZQUFNLFlBQVksU0FBUyxjQUFULENBQXdCLFlBQXhCLENBQWxCO0FBQ0Esa0JBQVUsU0FBVixHQUFzQixXQUF0QjtBQUNBLFlBQU0sWUFBWSxTQUFTLGNBQVQsQ0FBd0IsWUFBeEIsQ0FBbEI7QUFDQSxrQkFBVSxLQUFWLENBQWdCLE9BQWhCLEdBQTBCLE1BQTFCO0FBQ0EsY0FBTSxLQUFOLENBQVksT0FBWixHQUFzQixNQUF0QjtBQUNBLFlBQU0sY0FBYyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBcEI7QUFDQSxvQkFBWSxTQUFaLENBQXNCLEdBQXRCLENBQTBCLGNBQTFCO0FBQ0EsWUFBTSxRQUFRLFNBQVMsY0FBVCxDQUF3QixPQUF4QixDQUFkO0FBQ0EsY0FBTSxXQUFOLENBQWtCLFdBQWxCO0FBRUEsb0JBQVksU0FBWixHQUF3QixLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQXhCO0FBQ0EsWUFBTSxTQUFTLFlBQVksWUFBSztBQUM5QixnQkFBTSxVQUFVLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsU0FBakIsQ0FBaEI7QUFDQSx3QkFBWSxTQUFaLEdBQXdCLFFBQVEsTUFBUixDQUFlLE9BQWYsQ0FBeEI7QUFDRCxTQUhjLEVBR1osSUFIWSxDQUFmO0FBSUEsbUJBQVcsWUFBSztBQUNkLDBCQUFjLE1BQWQ7QUFDRCxTQUZELEVBRUcsU0FBUyxTQUFULEVBQW9CLEVBQXBCLElBQTBCLElBQTFCLEdBQWlDLEVBRnBDO0FBR0QsS0FyQkQ7QUFzQkQ7QUF6QkQsUUFBQSxRQUFBLEdBQUEsUUFBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vISBtb21lbnQuanNcclxuLy8hIHZlcnNpb24gOiAyLjI5LjFcclxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcclxuLy8hIGxpY2Vuc2UgOiBNSVRcclxuLy8hIG1vbWVudGpzLmNvbVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxyXG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxyXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgaG9va0NhbGxiYWNrO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhvb2tzKCkge1xyXG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxyXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXHJcbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxyXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xyXG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxyXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBpbnB1dCAhPSBudWxsICYmXHJcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaztcclxuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxyXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxyXG4gICAgICAgICAgICBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcclxuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xyXG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcclxuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZSxcclxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcclxuICAgICAgICAgICAgdW51c2VkSW5wdXQ6IFtdLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogLTIsXHJcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXHJcbiAgICAgICAgICAgIG51bGxJbnB1dDogZmFsc2UsXHJcbiAgICAgICAgICAgIGludmFsaWRFcmE6IG51bGwsXHJcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcclxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdDogZmFsc2UsXHJcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0czogW10sXHJcbiAgICAgICAgICAgIGVyYTogbnVsbCxcclxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXHJcbiAgICAgICAgICAgIHJmYzI4MjI6IGZhbHNlLFxyXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcclxuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0uX3BmO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzb21lO1xyXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XHJcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xyXG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcclxuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKSxcclxuICAgICAgICAgICAgICAgIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cclxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xyXG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkKGZsYWdzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcclxuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXHJcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxyXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcclxuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xyXG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XHJcblxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xyXG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XHJcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xyXG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcclxuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcclxuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XHJcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XHJcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcclxuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcclxuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcclxuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcclxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcclxuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxyXG4gICAgICAgIC8vIG9iamVjdHMuXHJcbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FyblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xyXG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmcgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBhcmd1bWVudHNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgICAgICAgICBtc2cgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSwgZm4pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xyXG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcclxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xyXG4gICAgICAgIHZhciBwcm9wLCBpO1xyXG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cclxuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxyXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cclxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXHJcbiAgICAgICAgICAgICAgICAnfCcgK1xyXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcclxuICAgICAgICAgICAgcHJvcDtcclxuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXHJcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcclxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXHJcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXlzO1xyXG5cclxuICAgIGlmIChPYmplY3Qua2V5cykge1xyXG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW1RvbW9ycm93IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XHJcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XHJcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcclxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxyXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXHJcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICtcclxuICAgICAgICAgICAgYWJzTnVtYmVyXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98TnsxLDV9fFlZWVlZWXxZWVlZWXxZWVlZfFlZfHl7Miw0fXx5bz98Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2csXHJcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZyxcclxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcclxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xyXG5cclxuICAgIC8vIHRva2VuOiAgICAnTSdcclxuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cclxuICAgIC8vIG9yZGluYWw6ICAnTW8nXHJcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cclxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFkZGVkKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmRpbmFsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xyXG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgbGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJyxcclxuICAgICAgICAgICAgICAgIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIDogYXJyYXlbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxyXG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XHJcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPVxyXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xyXG4gICAgICAgIHZhciBpID0gNTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBpIC09IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XHJcbiAgICAgICAgTFRTOiAnaDptbTpzcyBBJyxcclxuICAgICAgICBMVDogJ2g6bW0gQScsXHJcbiAgICAgICAgTDogJ01NL0REL1lZWVknLFxyXG4gICAgICAgIExMOiAnTU1NTSBELCBZWVlZJyxcclxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQScsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0KGtleSkge1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxyXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcclxuXHJcbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxyXG4gICAgICAgICAgICAubWF0Y2goZm9ybWF0dGluZ1Rva2VucylcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU1NTScgfHxcclxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTScgfHxcclxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcclxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdkZGRkJ1xyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xyXG5cclxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxyXG4gICAgICAgIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcclxuXHJcbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcclxuICAgICAgICBmdXR1cmU6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXHJcbiAgICAgICAgczogJ2EgZmV3IHNlY29uZHMnLFxyXG4gICAgICAgIHNzOiAnJWQgc2Vjb25kcycsXHJcbiAgICAgICAgbTogJ2EgbWludXRlJyxcclxuICAgICAgICBtbTogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGg6ICdhbiBob3VyJyxcclxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkOiAnYSBkYXknLFxyXG4gICAgICAgIGRkOiAnJWQgZGF5cycsXHJcbiAgICAgICAgdzogJ2Egd2VlaycsXHJcbiAgICAgICAgd3c6ICclZCB3ZWVrcycsXHJcbiAgICAgICAgTTogJ2EgbW9udGgnLFxyXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcclxuICAgICAgICB5OiAnYSB5ZWFyJyxcclxuICAgICAgICB5eTogJyVkIHllYXJzJyxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcclxuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpXHJcbiAgICAgICAgICAgID8gb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSlcclxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XHJcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXModW5pdCwgc2hvcnRoYW5kKSB7XHJcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxyXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcclxuICAgICAgICAgICAgcHJvcDtcclxuXHJcbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xyXG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XHJcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXHJcbiAgICAgICAgICAgIHU7XHJcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdHMucHVzaCh7IHVuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB1bml0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcclxuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IobnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcclxuICAgICAgICAgICAgLy8gLTAgLT4gMFxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XHJcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcclxuICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG5cclxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQodW5pdCwga2VlcFRpbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXQobW9tLCB1bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKClcclxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxyXG4gICAgICAgICAgICA6IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXQkMShtb20sIHVuaXQsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB1bml0ID09PSAnRnVsbFllYXInICYmXHJcbiAgICAgICAgICAgICAgICBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmXHJcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgbW9tLmRhdGUoKSA9PT0gMjlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XShcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0KHVuaXRzKSB7XHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQodW5pdHMsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XHJcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpLFxyXG4gICAgICAgICAgICAgICAgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxyXG4gICAgICAgIG1hdGNoMiA9IC9cXGRcXGQvLCAvLyAgICAgIDAwIC0gOTlcclxuICAgICAgICBtYXRjaDMgPSAvXFxkezN9LywgLy8gICAgIDAwMCAtIDk5OVxyXG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxyXG4gICAgICAgIG1hdGNoNiA9IC9bKy1dP1xcZHs2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcclxuICAgICAgICBtYXRjaDF0bzIgPSAvXFxkXFxkPy8sIC8vICAgICAgIDAgLSA5OVxyXG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcclxuICAgICAgICBtYXRjaDV0bzYgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy8sIC8vICAgOTk5OTkgLSA5OTk5OTlcclxuICAgICAgICBtYXRjaDF0bzMgPSAvXFxkezEsM30vLCAvLyAgICAgICAwIC0gOTk5XHJcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcclxuICAgICAgICBtYXRjaDF0bzYgPSAvWystXT9cXGR7MSw2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcclxuICAgICAgICBtYXRjaFVuc2lnbmVkID0gL1xcZCsvLCAvLyAgICAgICAwIC0gaW5mXHJcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxyXG4gICAgICAgIG1hdGNoT2Zmc2V0ID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpLCAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcclxuICAgICAgICBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2ksIC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXHJcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xyXG4gICAgICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxyXG4gICAgICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcclxuICAgICAgICBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcclxuICAgICAgICByZWdleGVzO1xyXG5cclxuICAgIHJlZ2V4ZXMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcclxuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXHJcbiAgICAgICAgICAgID8gcmVnZXhcclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxyXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xyXG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShcclxuICAgICAgICAgICAgc1xyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcXFwnLCAnJylcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHAzLFxyXG4gICAgICAgICAgICAgICAgICAgIHA0XHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xyXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0b2tlbnMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBmdW5jID0gY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xyXG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgWUVBUiA9IDAsXHJcbiAgICAgICAgTU9OVEggPSAxLFxyXG4gICAgICAgIERBVEUgPSAyLFxyXG4gICAgICAgIEhPVVIgPSAzLFxyXG4gICAgICAgIE1JTlVURSA9IDQsXHJcbiAgICAgICAgU0VDT05EID0gNSxcclxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXHJcbiAgICAgICAgV0VFSyA9IDcsXHJcbiAgICAgICAgV0VFS0RBWSA9IDg7XHJcblxyXG4gICAgZnVuY3Rpb24gbW9kKG4sIHgpIHtcclxuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZGV4T2Y7XHJcblxyXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XHJcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICAgICAgLy8gSSBrbm93XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xyXG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XHJcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcclxuICAgICAgICByZXR1cm4gbW9kTW9udGggPT09IDFcclxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXHJcbiAgICAgICAgICAgICAgICA/IDI5XHJcbiAgICAgICAgICAgICAgICA6IDI4XHJcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XHJcbiAgICB9KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xyXG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxyXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExPQ0FMRVNcclxuXHJcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdChcclxuICAgICAgICAgICAgJ18nXHJcbiAgICAgICAgKSxcclxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KFxyXG4gICAgICAgICAgICAnXydcclxuICAgICAgICApLFxyXG4gICAgICAgIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy8sXHJcbiAgICAgICAgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXHJcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyhtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNcclxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcclxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxyXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1tcclxuICAgICAgICAgICAgICAgICAgKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcclxuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXHJcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0KG0sIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcclxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRcclxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXHJcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxyXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0W1xyXG4gICAgICAgICAgICAgICAgICBNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXHJcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgaWksXHJcbiAgICAgICAgICAgIG1vbSxcclxuICAgICAgICAgICAgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcclxuICAgICAgICAgICAgICAgICAgICAnJ1xyXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcclxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXHJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xyXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcclxuICAgICAgICAgICAgICAgICAgICAnaSdcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2knXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgcmVnZXggPVxyXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XHJcblxyXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAvLyBObyBvcFxyXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcclxuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xyXG4gICAgICAgIHJldHVybiBtb207XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGgodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcclxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4KGlzU3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcclxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXhcclxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxyXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIG1vbTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XHJcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XHJcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xyXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XHJcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxyXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XHJcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXHJcbiAgICAgICAgICAgICdpJ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXHJcbiAgICAgICAgICAgICdpJ1xyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsIDVdLCAwLCAneWVhcicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcclxuXHJcbiAgICAvLyBQUklPUklUSUVTXHJcblxyXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCBtYXRjaDF0bzQsIG1hdGNoNCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuXHJcbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xyXG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcclxuICAgICAgICBhcnJheVtZRUFSXSA9XHJcbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSEVMUEVSU1xyXG5cclxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xyXG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhPT0tTXHJcblxyXG4gICAgaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcclxuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcclxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XHJcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XHJcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XHJcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUoeSkge1xyXG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xyXG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcclxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcclxuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XHJcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xyXG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXHJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXHJcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXHJcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcclxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xyXG5cclxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxyXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XHJcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxyXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcclxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcclxuICAgICAgICAgICAgcmVzWWVhcixcclxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xyXG5cclxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xyXG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xyXG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XHJcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XHJcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXHJcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XHJcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxyXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxyXG4gICAgICAgICAgICByZXNXZWVrLFxyXG4gICAgICAgICAgICByZXNZZWFyO1xyXG5cclxuICAgICAgICBpZiAod2VlayA8IDEpIHtcclxuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xyXG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcclxuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XHJcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcclxuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxyXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXHJcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XHJcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XHJcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xyXG5cclxuICAgIC8vIFBSSU9SSVRJRVNcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCd3JywgbWF0Y2gxdG8yKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoXHJcbiAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgd2VlayxcclxuICAgICAgICBjb25maWcsXHJcbiAgICAgICAgdG9rZW5cclxuICAgICkge1xyXG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhFTFBFUlNcclxuXHJcbiAgICAvLyBMT0NBTEVTXHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vlayhtb20pIHtcclxuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XHJcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3k6IDYsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xyXG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayhpbnB1dCkge1xyXG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xyXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XHJcblxyXG4gICAgLy8gQUxJQVNFU1xyXG5cclxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcclxuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XHJcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xyXG5cclxuICAgIC8vIFBSSU9SSVRZXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCBtYXRjaDF0bzIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XHJcbiAgICB9KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfSk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XHJcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXHJcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhFTFBFUlNcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExPQ0FMRVNcclxuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcclxuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdChcclxuICAgICAgICAgICAgJ18nXHJcbiAgICAgICAgKSxcclxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxyXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXHJcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgdmFyIHdlZWtkYXlzID0gaXNBcnJheSh0aGlzLl93ZWVrZGF5cylcclxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xyXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzW1xyXG4gICAgICAgICAgICAgICAgICBtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXHJcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xyXG4gICAgICAgICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcclxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcclxuICAgICAgICAgICAgOiBtXHJcbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cclxuICAgICAgICAgICAgOiB3ZWVrZGF5cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcclxuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXHJcbiAgICAgICAgICAgIDogbVxyXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV1cclxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcclxuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNNaW4sIHRoaXMuX3dlZWsuZG93KVxyXG4gICAgICAgICAgICA6IG1cclxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxyXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGlpLFxyXG4gICAgICAgICAgICBtb20sXHJcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcclxuICAgICAgICAgICAgICAgICAgICAnJ1xyXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcclxuICAgICAgICAgICAgICAgICAgICAnJ1xyXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xyXG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxyXG5cclxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xyXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcclxuICAgICAgICAgICAgICAgICAgICAnaSdcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxyXG4gICAgICAgICAgICAgICAgICAgICdpJ1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcclxuICAgICAgICAgICAgICAgICAgICAnaSdcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZWdleCA9XHJcbiAgICAgICAgICAgICAgICAgICAgJ14nICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzKG1vbSwgJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnfF4nICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XHJcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayhpbnB1dCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xyXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcclxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxyXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cclxuXHJcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcclxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleFxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcclxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXhcclxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcclxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSxcclxuICAgICAgICAgICAgc2hvcnRQaWVjZXMgPSBbXSxcclxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxyXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBtb20sXHJcbiAgICAgICAgICAgIG1pbnAsXHJcbiAgICAgICAgICAgIHNob3J0cCxcclxuICAgICAgICAgICAgbG9uZ3A7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xyXG4gICAgICAgICAgICBtaW5wID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c01pbihtb20sICcnKSk7XHJcbiAgICAgICAgICAgIHNob3J0cCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSk7XHJcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XHJcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xyXG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XHJcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxyXG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cclxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XHJcblxyXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcclxuXHJcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcclxuICAgICAgICAgICAgJ2knXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxyXG4gICAgICAgICAgICAnaSdcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcclxuICAgICAgICAgICAgJ2knXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAnJyArXHJcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xyXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xyXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcclxuICAgICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgJycgK1xyXG4gICAgICAgICAgICB0aGlzLmhvdXJzKCkgK1xyXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xyXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcclxuICAgICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xyXG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcclxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygpLFxyXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcclxuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xyXG5cclxuICAgIC8vIFBSSU9SSVRZXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0oaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xyXG4gICAgYWRkUmVnZXhUb2tlbignQScsIG1hdGNoTWVyaWRpZW0pO1xyXG4gICAgYWRkUmVnZXhUb2tlbignSCcsIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCBtYXRjaDF0bzIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xyXG5cclxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xyXG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcclxuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xyXG4gICAgfSk7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xyXG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xyXG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxyXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcclxuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XHJcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XHJcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xyXG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XHJcbiAgICB9KTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxyXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcclxuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XHJcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XHJcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBMT0NBTEVTXHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTShpbnB1dCkge1xyXG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcclxuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cclxuICAgICAgICByZXR1cm4gKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2ksXHJcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cclxuICAgICAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcclxuICAgICAgICAvLyB0aGlzIHJ1bGUuXHJcbiAgICAgICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlQ29uZmlnID0ge1xyXG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXHJcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcclxuICAgICAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxyXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxyXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxyXG4gICAgICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcclxuXHJcbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxyXG4gICAgICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXHJcblxyXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxyXG5cclxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxyXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXHJcbiAgICAgICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXHJcblxyXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXHJcbiAgICB2YXIgbG9jYWxlcyA9IHt9LFxyXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXHJcbiAgICAgICAgZ2xvYmFsTG9jYWxlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIG1pbmwgPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaW5sO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcclxuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XHJcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxyXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxyXG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBuZXh0LFxyXG4gICAgICAgICAgICBsb2NhbGUsXHJcbiAgICAgICAgICAgIHNwbGl0O1xyXG5cclxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcclxuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcclxuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xyXG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQubGVuZ3RoID49IGogJiZcclxuICAgICAgICAgICAgICAgICAgICBjb21tb25QcmVmaXgoc3BsaXQsIG5leHQpID49IGogLSAxXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xyXG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxyXG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZTtcclxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIG1vZHVsZSAmJlxyXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0c1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xyXG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xyXG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGZpbmQgZW4tVVMsIGVuX1VTLCBlbi11cyBmb3IgZXZlcnkgZm9ybWF0IGNhbGxcclxuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBudWxsOyAvLyBudWxsIG1lYW5zIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxyXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcclxuICAgIC8vIGxvY2FsZSBrZXkuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUoa2V5LCB2YWx1ZXMpIHtcclxuICAgICAgICB2YXIgZGF0YTtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xyXG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsZSxcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XHJcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxyXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbmVMb2NhbGVPdmVycmlkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxyXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcclxuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXHJcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2hpbGQgbG9jYWxlIGluLXBsYWNlIHRvIGF2b2lkIG1lbW9yeS1sZWFrc1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQobWVyZ2VDb25maWdzKGxvY2FsZXNbbmFtZV0uX2NvbmZpZywgY29uZmlnKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNRVJHRVxyXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUxvY2FsZSBpcyBjYWxsZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG90aGVyd2lzZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcclxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXHJcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBnZXRTZXRHbG9iYWxMb2NhbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXHJcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUoa2V5KSB7XHJcbiAgICAgICAgdmFyIGxvY2FsZTtcclxuXHJcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xyXG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xyXG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcclxuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3csXHJcbiAgICAgICAgICAgIGEgPSBtLl9hO1xyXG5cclxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93ID1cclxuICAgICAgICAgICAgICAgIGFbTU9OVEhdIDwgMCB8fCBhW01PTlRIXSA+IDExXHJcbiAgICAgICAgICAgICAgICAgICAgPyBNT05USFxyXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxyXG4gICAgICAgICAgICAgICAgICAgID8gREFURVxyXG4gICAgICAgICAgICAgICAgICAgIDogYVtIT1VSXSA8IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgKGFbSE9VUl0gPT09IDI0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGFbTUlOVVRFXSAhPT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgID8gSE9VUlxyXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxyXG4gICAgICAgICAgICAgICAgICAgID8gTUlOVVRFXHJcbiAgICAgICAgICAgICAgICAgICAgOiBhW1NFQ09ORF0gPCAwIHx8IGFbU0VDT05EXSA+IDU5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcclxuICAgICAgICAgICAgICAgICAgICA6IGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OVxyXG4gICAgICAgICAgICAgICAgICAgID8gTUlMTElTRUNPTkRcclxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xyXG5cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxyXG4gICAgICAgICAgICAgICAgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XHJcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcclxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXHJcbiAgICAgICAgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGR8KSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXHJcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcclxuICAgICAgICBpc29EYXRlcyA9IFtcclxuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXHJcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxyXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcclxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxyXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcclxuICAgICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXHJcbiAgICAgICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxyXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxyXG4gICAgICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxyXG4gICAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxyXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXHJcbiAgICAgICAgICAgIFsnWVlZWU1NJywgL1xcZHs2fS8sIGZhbHNlXSxcclxuICAgICAgICAgICAgWydZWVlZJywgL1xcZHs0fS8sIGZhbHNlXSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcclxuICAgICAgICBpc29UaW1lcyA9IFtcclxuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxyXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxyXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXHJcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxyXG4gICAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcclxuICAgICAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxyXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcclxuICAgICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxyXG4gICAgICAgICAgICBbJ0hIJywgL1xcZFxcZC9dLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKCgtP1xcZCspL2ksXHJcbiAgICAgICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xyXG4gICAgICAgIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvLFxyXG4gICAgICAgIG9ic09mZnNldHMgPSB7XHJcbiAgICAgICAgICAgIFVUOiAwLFxyXG4gICAgICAgICAgICBHTVQ6IDAsXHJcbiAgICAgICAgICAgIEVEVDogLTQgKiA2MCxcclxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxyXG4gICAgICAgICAgICBDRFQ6IC01ICogNjAsXHJcbiAgICAgICAgICAgIENTVDogLTYgKiA2MCxcclxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxyXG4gICAgICAgICAgICBNU1Q6IC03ICogNjAsXHJcbiAgICAgICAgICAgIFBEVDogLTcgKiA2MCxcclxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcclxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGwsXHJcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcclxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcclxuICAgICAgICAgICAgYWxsb3dUaW1lLFxyXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxyXG4gICAgICAgICAgICB0aW1lRm9ybWF0LFxyXG4gICAgICAgICAgICB0ekZvcm1hdDtcclxuXHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcclxuICAgICAgICB5ZWFyU3RyLFxyXG4gICAgICAgIG1vbnRoU3RyLFxyXG4gICAgICAgIGRheVN0cixcclxuICAgICAgICBob3VyU3RyLFxyXG4gICAgICAgIG1pbnV0ZVN0cixcclxuICAgICAgICBzZWNvbmRTdHJcclxuICAgICkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXHJcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxyXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXHJcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxyXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXHJcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApLFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XHJcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XHJcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geWVhcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcclxuICAgICAgICByZXR1cm4gc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHNcXHMqLywgJycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xyXG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cclxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMl1cclxuICAgICAgICAgICAgICAgICkuZ2V0RGF5KCk7XHJcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcclxuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcclxuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApLFxyXG4gICAgICAgICAgICAgICAgbSA9IGhtICUgMTAwLFxyXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xyXG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpLFxyXG4gICAgICAgICAgICBwYXJzZWRBcnJheTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0sXHJcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcclxuICAgICAgICAgICAgICAgIG1hdGNoWzJdLFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0sXHJcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcclxuICAgICAgICAgICAgICAgIG1hdGNoWzddXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcclxuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xyXG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xyXG5cclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGRhdGUgZnJvbSAxKSBBU1AuTkVULCAyKSBJU08sIDMpIFJGQyAyODIyIGZvcm1hdHMsIG9yIDQpIG9wdGlvbmFsIGZhbGxiYWNrIGlmIHBhcnNpbmcgaXNuJ3Qgc3RyaWN0XHJcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcclxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcclxuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXHJcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXHJcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xyXG4gICAgICAgICAgICAnZGlzY291cmFnZWQuIFBsZWFzZSByZWZlciB0byBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcclxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XHJcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcclxuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxyXG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcclxuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXHJcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXHJcbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xyXG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cclxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheShjb25maWcpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgaW5wdXQgPSBbXSxcclxuICAgICAgICAgICAgY3VycmVudERhdGUsXHJcbiAgICAgICAgICAgIGV4cGVjdGVkV2Vla2RheSxcclxuICAgICAgICAgICAgeWVhclRvVXNlO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xyXG5cclxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcclxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxyXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcclxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXHJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXHJcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW2ldID09IG51bGwgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcclxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcclxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcclxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBpbnB1dFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVENcclxuICAgICAgICAgICAgPyBjb25maWcuX2QuZ2V0VVRDRGF5KClcclxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxyXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxyXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBjb25maWcuX3cgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcclxuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XHJcblxyXG4gICAgICAgIHcgPSBjb25maWcuX3c7XHJcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkb3cgPSAxO1xyXG4gICAgICAgICAgICBkb3kgPSA0O1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXHJcbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcclxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcclxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXHJcbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMoXHJcbiAgICAgICAgICAgICAgICB3LkdHLFxyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxyXG4gICAgICAgICAgICAgICAgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xyXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcclxuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xyXG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XHJcblxyXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XHJcblxyXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxyXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xyXG5cclxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xyXG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcclxuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxyXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxyXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXHJcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xyXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcclxuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uZmlnLl9hID0gW107XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxyXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgcGFyc2VkSW5wdXQsXHJcbiAgICAgICAgICAgIHRva2VucyxcclxuICAgICAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgICAgIHNraXBwZWQsXHJcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxyXG4gICAgICAgICAgICBlcmE7XHJcblxyXG4gICAgICAgIHRva2VucyA9XHJcbiAgICAgICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHxcclxuICAgICAgICAgICAgICAgIFtdKVswXTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID1cclxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcclxuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XHJcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXHJcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKFxyXG4gICAgICAgICAgICBjb25maWcuX2xvY2FsZSxcclxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxyXG4gICAgICAgICAgICBjb25maWcuX21lcmlkaWVtXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIGVyYVxyXG4gICAgICAgIGVyYSA9IGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYTtcclxuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNDb252ZXJ0WWVhcihlcmEsIGNvbmZpZy5fYVtZRUFSXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcclxuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICB2YXIgaXNQbTtcclxuXHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXHJcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XHJcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcclxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcclxuICAgICAgICB2YXIgdGVtcENvbmZpZyxcclxuICAgICAgICAgICAgYmVzdE1vbWVudCxcclxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcclxuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCxcclxuICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcclxuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XHJcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcclxuXHJcbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXHJcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xyXG5cclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFiZXN0Rm9ybWF0SXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZvcm1hdEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xyXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxyXG4gICAgICAgICAgICBkYXlPckRhdGUgPSBpLmRheSA9PT0gdW5kZWZpbmVkID8gaS5kYXRlIDogaS5kYXk7XHJcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFxyXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcclxuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XHJcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxyXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XHJcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyhjb25maWcpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcclxuXHJcbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcclxuXHJcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xyXG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xyXG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcclxuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XHJcbiAgICAgICAgdmFyIGMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHN0cmljdCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcclxuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxyXG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcclxuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xyXG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XHJcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcclxuICAgICAgICBjLl9pID0gaW5wdXQ7XHJcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcclxuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XHJcblxyXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcclxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxyXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxyXG4gICAgLy9cclxuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcclxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXHJcbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcclxuICAgICAgICB2YXIgcmVzLCBpO1xyXG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XHJcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XHJcbiAgICBmdW5jdGlvbiBtaW4oKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWF4KCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogK25ldyBEYXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBvcmRlcmluZyA9IFtcclxuICAgICAgICAneWVhcicsXHJcbiAgICAgICAgJ3F1YXJ0ZXInLFxyXG4gICAgICAgICdtb250aCcsXHJcbiAgICAgICAgJ3dlZWsnLFxyXG4gICAgICAgICdkYXknLFxyXG4gICAgICAgICdob3VyJyxcclxuICAgICAgICAnbWludXRlJyxcclxuICAgICAgICAnc2Vjb25kJyxcclxuICAgICAgICAnbWlsbGlzZWNvbmQnLFxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xyXG4gICAgICAgIHZhciBrZXksXHJcbiAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gZmFsc2UsXHJcbiAgICAgICAgICAgIGk7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gbSkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKG0sIGtleSkgJiZcclxuICAgICAgICAgICAgICAgICEoXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxyXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXHJcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxyXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXHJcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXHJcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcclxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcclxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XHJcblxyXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcclxuXHJcbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcclxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPVxyXG4gICAgICAgICAgICArbWlsbGlzZWNvbmRzICtcclxuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcclxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxyXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcclxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcclxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XHJcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICsgd2Vla3MgKiA3O1xyXG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXHJcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcclxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxyXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xyXG5cclxuICAgICAgICB0aGlzLl9kYXRhID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xyXG5cclxuICAgICAgICB0aGlzLl9idWJibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcclxuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xyXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcclxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcclxuICAgICAgICAgICAgZGlmZnMgPSAwLFxyXG4gICAgICAgICAgICBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XHJcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgZGlmZnMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBmdW5jdGlvbiBvZmZzZXQodG9rZW4sIHNlcGFyYXRvcikge1xyXG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICcrJztcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICBzaWduICtcclxuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgK1xyXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcclxuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+b2Zmc2V0ICUgNjAsIDIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcclxuICAgIG9mZnNldCgnWlonLCAnJyk7XHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCBtYXRjaFNob3J0T2Zmc2V0KTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XHJcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhFTFBFUlNcclxuXHJcbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXHJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cclxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxyXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xyXG5cclxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSxcclxuICAgICAgICAgICAgY2h1bmssXHJcbiAgICAgICAgICAgIHBhcnRzLFxyXG4gICAgICAgICAgICBtaW51dGVzO1xyXG5cclxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xyXG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcclxuICAgICAgICBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxyXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xyXG4gICAgICAgIHZhciByZXMsIGRpZmY7XHJcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xyXG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBkaWZmID1cclxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxyXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQudmFsdWVPZigpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cclxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xyXG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcclxuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxyXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhPT0tTXHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxyXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXHJcbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XHJcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxyXG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxyXG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxyXG4gICAgLy9cclxuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxyXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XHJcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXHJcbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcclxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxyXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcclxuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcclxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcclxuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xyXG5cclxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XHJcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCgpIHtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjID0ge30sXHJcbiAgICAgICAgICAgIG90aGVyO1xyXG5cclxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xyXG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xyXG5cclxuICAgICAgICBpZiAoYy5fYSkge1xyXG4gICAgICAgICAgICBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0xvY2FsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVdGMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XHJcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcclxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxyXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcclxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XHJcbiAgICAgICAgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcclxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcclxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxyXG4gICAgICAgICAgICBzaWduLFxyXG4gICAgICAgICAgICByZXQsXHJcbiAgICAgICAgICAgIGRpZmZSZXM7XHJcblxyXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxyXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXHJcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpIHx8ICFpc05hTigraW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSAraW5wdXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xyXG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcclxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXHJcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXHJcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXHJcbiAgICAgICAgICAgICAgICBtczogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiwgLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxyXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xyXG5cclxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xyXG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19pc1ZhbGlkJykpIHtcclxuICAgICAgICAgICAgcmV0Ll9pc1ZhbGlkID0gaW5wdXQuX2lzVmFsaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xyXG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUlzbyhpbnAsIHNpZ24pIHtcclxuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xyXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxyXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cclxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcclxuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XHJcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcclxuICAgICAgICB2YXIgcmVzID0ge307XHJcblxyXG4gICAgICAgIHJlcy5tb250aHMgPVxyXG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xyXG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcclxuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICtiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJyk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcclxuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XHJcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcclxuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XHJcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJpb2Q7XHJcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcclxuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcclxuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcclxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcclxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XHJcblxyXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAvLyBObyBvcFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChtb250aHMpIHtcclxuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRheXMpIHtcclxuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XHJcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcclxuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWRkID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpLFxyXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXHJcbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0KGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XHJcbiAgICAgICAgICAgIGlzRGF0ZShpbnB1dCkgfHxcclxuICAgICAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XHJcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxyXG4gICAgICAgICAgICBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHx8XHJcbiAgICAgICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XHJcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIGlucHV0ID09PSB1bmRlZmluZWRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHtcclxuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXHJcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcclxuICAgICAgICAgICAgICAgICd5ZWFyJyxcclxuICAgICAgICAgICAgICAgICd5JyxcclxuICAgICAgICAgICAgICAgICdtb250aHMnLFxyXG4gICAgICAgICAgICAgICAgJ21vbnRoJyxcclxuICAgICAgICAgICAgICAgICdNJyxcclxuICAgICAgICAgICAgICAgICdkYXlzJyxcclxuICAgICAgICAgICAgICAgICdkYXknLFxyXG4gICAgICAgICAgICAgICAgJ2QnLFxyXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcclxuICAgICAgICAgICAgICAgICdkYXRlJyxcclxuICAgICAgICAgICAgICAgICdEJyxcclxuICAgICAgICAgICAgICAgICdob3VycycsXHJcbiAgICAgICAgICAgICAgICAnaG91cicsXHJcbiAgICAgICAgICAgICAgICAnaCcsXHJcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXHJcbiAgICAgICAgICAgICAgICAnbWludXRlJyxcclxuICAgICAgICAgICAgICAgICdtJyxcclxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcclxuICAgICAgICAgICAgICAgICdzZWNvbmQnLFxyXG4gICAgICAgICAgICAgICAgJ3MnLFxyXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXHJcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxyXG4gICAgICAgICAgICAgICAgJ21zJyxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgcHJvcGVydHk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHtcclxuICAgICAgICB2YXIgYXJyYXlUZXN0ID0gaXNBcnJheShpbnB1dCksXHJcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChhcnJheVRlc3QpIHtcclxuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID1cclxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdW1iZXIoaXRlbSkgJiYgaXNTdHJpbmcoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXlUZXN0ICYmIGRhdGFUeXBlVGVzdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0NhbGVuZGFyU3BlYyhpbnB1dCkge1xyXG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcclxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAnc2FtZURheScsXHJcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXHJcbiAgICAgICAgICAgICAgICAnbGFzdERheScsXHJcbiAgICAgICAgICAgICAgICAnbmV4dFdlZWsnLFxyXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcclxuICAgICAgICAgICAgICAgICdzYW1lRWxzZScsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIHByb3BlcnR5O1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xyXG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNlxyXG4gICAgICAgICAgICA/ICdzYW1lRWxzZSdcclxuICAgICAgICAgICAgOiBkaWZmIDwgLTFcclxuICAgICAgICAgICAgPyAnbGFzdFdlZWsnXHJcbiAgICAgICAgICAgIDogZGlmZiA8IDBcclxuICAgICAgICAgICAgPyAnbGFzdERheSdcclxuICAgICAgICAgICAgOiBkaWZmIDwgMVxyXG4gICAgICAgICAgICA/ICdzYW1lRGF5J1xyXG4gICAgICAgICAgICA6IGRpZmYgPCAyXHJcbiAgICAgICAgICAgID8gJ25leHREYXknXHJcbiAgICAgICAgICAgIDogZGlmZiA8IDdcclxuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXHJcbiAgICAgICAgICAgIDogJ3NhbWVFbHNlJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcclxuICAgICAgICAvLyBTdXBwb3J0IGZvciBzaW5nbGUgcGFyYW1ldGVyLCBmb3JtYXRzIG9ubHkgb3ZlcmxvYWQgdG8gdGhlIGNhbGVuZGFyIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgdGltZSA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cclxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cclxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxyXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxyXG4gICAgICAgICAgICBvdXRwdXQgPVxyXG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxyXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxyXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KVxyXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KFxyXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNBZnRlcihpbnB1dCwgdW5pdHMpIHtcclxuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xyXG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XHJcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xyXG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XHJcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcclxuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQmV0d2Vlbihmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XHJcbiAgICAgICAgdmFyIGxvY2FsRnJvbSA9IGlzTW9tZW50KGZyb20pID8gZnJvbSA6IGNyZWF0ZUxvY2FsKGZyb20pLFxyXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XHJcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcclxuICAgICAgICAgICAgICAgID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpXHJcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxyXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKVxyXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcclxuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxyXG4gICAgICAgICAgICBpbnB1dE1zO1xyXG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XHJcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXHJcbiAgICAgICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpZmYoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XHJcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcclxuXHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcclxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXHJcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcclxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XHJcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xyXG4gICAgICAgICAgICAvLyBlbmQtb2YtbW9udGggY2FsY3VsYXRpb25zIHdvcmsgY29ycmVjdCB3aGVuIHRoZSBzdGFydCBtb250aCBoYXMgbW9yZVxyXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cclxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXHJcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcclxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcclxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxyXG4gICAgICAgICAgICBhbmNob3IyLFxyXG4gICAgICAgICAgICBhZGp1c3Q7XHJcblxyXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xyXG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcclxuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcclxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xyXG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxyXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXHJcbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XHJcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWUsXHJcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xyXG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXHJcbiAgICAgICAgICAgICAgICBtLFxyXG4gICAgICAgICAgICAgICAgdXRjXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJ1xyXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxyXG4gICAgICAgICAgICBpZiAodXRjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMClcclxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXHJcbiAgICAgICAgICAgIG0sXHJcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cclxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcclxuICAgICAqXHJcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbnNwZWN0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JyxcclxuICAgICAgICAgICAgem9uZSA9ICcnLFxyXG4gICAgICAgICAgICBwcmVmaXgsXHJcbiAgICAgICAgICAgIHllYXIsXHJcbiAgICAgICAgICAgIGRhdGV0aW1lLFxyXG4gICAgICAgICAgICBzdWZmaXg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xyXG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcclxuICAgICAgICAgICAgem9uZSA9ICdaJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcclxuICAgICAgICB5ZWFyID0gMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5ID8gJ1lZWVknIDogJ1lZWVlZWSc7XHJcbiAgICAgICAgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcclxuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZm9ybWF0KGlucHV0U3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xyXG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKVxyXG4gICAgICAgICAgICAgICAgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjXHJcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxyXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IHRvOiB0aGlzLCBmcm9tOiB0aW1lIH0pXHJcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXHJcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXHJcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZnJvbTogdGhpcywgdG86IHRpbWUgfSlcclxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcclxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXHJcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXHJcbiAgICBmdW5jdGlvbiBsb2NhbGUoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XHJcblxyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcclxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXHJcbiAgICAgICAgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORCxcclxuICAgICAgICBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURSxcclxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XHJcblxyXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcclxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XHJcbiAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcclxuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcclxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcclxuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XHJcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XHJcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XHJcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XHJcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxyXG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSxcclxuICAgICAgICAgICAgICAgICAgICAxXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcclxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXknOlxyXG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcclxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLFxyXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XHJcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XHJcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XHJcbiAgICAgICAgICAgICAgICB0aW1lID1cclxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSArIDMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcclxuICAgICAgICAgICAgICAgICAgICApIC0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgICAgIHRpbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgN1xyXG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxyXG4gICAgICAgICAgICAgICAgdGltZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3XHJcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lICs9XHJcbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVIgLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcclxuICAgICAgICAgICAgICAgICAgICApIC1cclxuICAgICAgICAgICAgICAgICAgICAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XHJcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcclxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xyXG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bml4KCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9EYXRlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcclxuICAgICAgICB2YXIgbSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbS55ZWFyKCksXHJcbiAgICAgICAgICAgIG0ubW9udGgoKSxcclxuICAgICAgICAgICAgbS5kYXRlKCksXHJcbiAgICAgICAgICAgIG0uaG91cigpLFxyXG4gICAgICAgICAgICBtLm1pbnV0ZSgpLFxyXG4gICAgICAgICAgICBtLnNlY29uZCgpLFxyXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b09iamVjdCgpIHtcclxuICAgICAgICB2YXIgbSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxyXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcclxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXHJcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXHJcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxyXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMigpIHtcclxuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcclxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXHJcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcclxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3QsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignTicsIDAsIDAsICdlcmFBYmJyJyk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTicsIDAsIDAsICdlcmFBYmJyJyk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTicsIDAsIDAsICdlcmFOYW1lJyk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3knLCAxXSwgJ3lvJywgJ2VyYVllYXInKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eXknLCA0XSwgMCwgJ2VyYVllYXInKTtcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdOJywgbWF0Y2hFcmFBYmJyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ05OJywgbWF0Y2hFcmFBYmJyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OJywgbWF0Y2hFcmFOYW1lKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTk5OJywgbWF0Y2hFcmFOYXJyb3cpO1xyXG5cclxuICAgIGFkZFBhcnNlVG9rZW4oWydOJywgJ05OJywgJ05OTicsICdOTk5OJywgJ05OTk5OJ10sIGZ1bmN0aW9uIChcclxuICAgICAgICBpbnB1dCxcclxuICAgICAgICBhcnJheSxcclxuICAgICAgICBjb25maWcsXHJcbiAgICAgICAgdG9rZW5cclxuICAgICkge1xyXG4gICAgICAgIHZhciBlcmEgPSBjb25maWcuX2xvY2FsZS5lcmFzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XHJcbiAgICAgICAgaWYgKGVyYSkge1xyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEVyYSA9IGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5JywgbWF0Y2hVbnNpZ25lZCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ3lvJywgbWF0Y2hFcmFZZWFyT3JkaW5hbCk7XHJcblxyXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XHJcbiAgICBhZGRQYXJzZVRva2VuKFsneW8nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcclxuICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZSkge1xyXG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UoaW5wdXQsIG1hdGNoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgbCxcclxuICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnVudGlsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS51bnRpbCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSBkYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJhcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgbCxcclxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBhYmJyLFxyXG4gICAgICAgICAgICBuYXJyb3c7XHJcbiAgICAgICAgZXJhTmFtZSA9IGVyYU5hbWUudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBlcmFzW2ldLm5hbWUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTic6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiYnIgPT09IGVyYU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVyYU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXJyb3cgPT09IGVyYU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xyXG4gICAgICAgIHZhciBkaXIgPSBlcmEuc2luY2UgPD0gZXJhLnVudGlsID8gKzEgOiAtMTtcclxuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCkgKyAoeWVhciAtIGVyYS5vZmZzZXQpICogZGlyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBsLFxyXG4gICAgICAgICAgICB2YWwsXHJcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRFcmFOYXJyb3coKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGwsXHJcbiAgICAgICAgICAgIHZhbCxcclxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRFcmFBYmJyKCkge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBsLFxyXG4gICAgICAgICAgICB2YWwsXHJcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBsLFxyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIHZhbCxcclxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgZGlyID0gZXJhc1tpXS5zaW5jZSA8PSBlcmFzW2ldLnVudGlsID8gKzEgOiAtMTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkgfHxcclxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnllYXIoKSAtIGhvb2tzKGVyYXNbaV0uc2luY2UpLnllYXIoKSkgKiBkaXIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xyXG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNBYmJyUmVnZXgnKSkge1xyXG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNBYmJyUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hcnJvd1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFycm93UmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hcnJvdyhpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xyXG4gICAgICAgIHZhciBhYmJyUGllY2VzID0gW10sXHJcbiAgICAgICAgICAgIG5hbWVQaWVjZXMgPSBbXSxcclxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXHJcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGwsXHJcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5hbWVQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcclxuICAgICAgICAgICAgYWJiclBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xyXG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xyXG5cclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcclxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZXJhc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgICAgIHRoaXMuX2VyYXNOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBuYW1lUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbiAgICAgICAgdGhpcy5fZXJhc05hcnJvd1JlZ2V4ID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgJ14oJyArIG5hcnJvd1BpZWNlcy5qb2luKCd8JykgKyAnKScsXHJcbiAgICAgICAgICAgICdpJ1xyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbih0b2tlbiwgZ2V0dGVyKSB7XHJcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcclxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgJ3dlZWtZZWFyJyk7XHJcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XHJcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XHJcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuXHJcbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoXHJcbiAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgd2VlayxcclxuICAgICAgICBjb25maWcsXHJcbiAgICAgICAgdG9rZW5cclxuICAgICkge1xyXG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XHJcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcclxuICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxyXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcclxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxyXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwoXHJcbiAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgIGlucHV0LFxyXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWsoKSxcclxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXHJcbiAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgIDRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xyXG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyKCkge1xyXG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLmlzb1dlZWtZZWFyKCksIDEsIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyKCkge1xyXG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xyXG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcclxuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcclxuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XHJcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xyXG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcclxuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcclxuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxyXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcclxuXHJcbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XHJcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xyXG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcclxuXHJcbiAgICAvLyBQUklPUklUWVxyXG5cclxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xyXG5cclxuICAgIC8vIFBBUlNJTkdcclxuXHJcbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcclxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcclxuICAgICAgICAgICAgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArICh0aGlzLm1vbnRoKCkgJSAzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xyXG5cclxuICAgIC8vIFBSSU9SSVRZXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0XHJcbiAgICAgICAgICAgID8gbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlXHJcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xyXG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XHJcblxyXG4gICAgLy8gUEFSU0lOR1xyXG5cclxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsIG1hdGNoMXRvMyk7XHJcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhFTFBFUlNcclxuXHJcbiAgICAvLyBNT01FTlRTXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XHJcbiAgICAgICAgICAgIE1hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgICAodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNVxyXG4gICAgICAgICAgICApICsgMTtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKGlucHV0IC0gZGF5T2ZZZWFyLCAnZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xyXG5cclxuICAgIC8vIEFMSUFTRVNcclxuXHJcbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XHJcblxyXG4gICAgLy8gUFJJT1JJVFlcclxuXHJcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbigncycsIG1hdGNoMXRvMik7XHJcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XHJcblxyXG4gICAgLy8gTU9NRU5UU1xyXG5cclxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xyXG5cclxuICAgIC8vIEZPUk1BVFRJTkdcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xyXG4gICAgfSk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xyXG4gICAgfSk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XHJcbiAgICB9KTtcclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xyXG4gICAgfSk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xyXG4gICAgfSk7XHJcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBTElBU0VTXHJcblxyXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xyXG5cclxuICAgIC8vIFBSSU9SSVRZXHJcblxyXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgbWF0Y2gxdG8zLCBtYXRjaDIpO1xyXG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xyXG5cclxuICAgIHZhciB0b2tlbiwgZ2V0U2V0TWlsbGlzZWNvbmQ7XHJcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XHJcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcclxuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcclxuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcclxuXHJcbiAgICAvLyBGT1JNQVRUSU5HXHJcblxyXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xyXG5cclxuICAgIC8vIE1PTUVOVFNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xyXG5cclxuICAgIHByb3RvLmFkZCA9IGFkZDtcclxuICAgIHByb3RvLmNhbGVuZGFyID0gY2FsZW5kYXIkMTtcclxuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XHJcbiAgICBwcm90by5kaWZmID0gZGlmZjtcclxuICAgIHByb3RvLmVuZE9mID0gZW5kT2Y7XHJcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICBwcm90by5mcm9tID0gZnJvbTtcclxuICAgIHByb3RvLmZyb21Ob3cgPSBmcm9tTm93O1xyXG4gICAgcHJvdG8udG8gPSB0bztcclxuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XHJcbiAgICBwcm90by5nZXQgPSBzdHJpbmdHZXQ7XHJcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XHJcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcclxuICAgIHByb3RvLmlzQmVmb3JlID0gaXNCZWZvcmU7XHJcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XHJcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XHJcbiAgICBwcm90by5pc1NhbWVPckFmdGVyID0gaXNTYW1lT3JBZnRlcjtcclxuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XHJcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xyXG4gICAgcHJvdG8ubGFuZyA9IGxhbmc7XHJcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcclxuICAgIHByb3RvLm1heCA9IHByb3RvdHlwZU1heDtcclxuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcclxuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcclxuICAgIHByb3RvLnNldCA9IHN0cmluZ1NldDtcclxuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xyXG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcclxuICAgIHByb3RvLnRvQXJyYXkgPSB0b0FycmF5O1xyXG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcclxuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcclxuICAgIHByb3RvLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmc7XHJcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcclxuICAgICAgICBwcm90b1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcclxuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XHJcbiAgICBwcm90by51bml4ID0gdW5peDtcclxuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xyXG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xyXG4gICAgcHJvdG8uZXJhTmFtZSA9IGdldEVyYU5hbWU7XHJcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XHJcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcclxuICAgIHByb3RvLmVyYVllYXIgPSBnZXRFcmFZZWFyO1xyXG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XHJcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcclxuICAgIHByb3RvLndlZWtZZWFyID0gZ2V0U2V0V2Vla1llYXI7XHJcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xyXG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcclxuICAgIHByb3RvLm1vbnRoID0gZ2V0U2V0TW9udGg7XHJcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xyXG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcclxuICAgIHByb3RvLmlzb1dlZWsgPSBwcm90by5pc29XZWVrcyA9IGdldFNldElTT1dlZWs7XHJcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xyXG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xyXG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcclxuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcclxuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xyXG4gICAgcHJvdG8uZGF5ID0gcHJvdG8uZGF5cyA9IGdldFNldERheU9mV2VlaztcclxuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XHJcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xyXG4gICAgcHJvdG8uZGF5T2ZZZWFyID0gZ2V0U2V0RGF5T2ZZZWFyO1xyXG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcclxuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XHJcbiAgICBwcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xyXG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcclxuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcclxuICAgIHByb3RvLnV0YyA9IHNldE9mZnNldFRvVVRDO1xyXG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xyXG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XHJcbiAgICBwcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xyXG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcclxuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xyXG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgPSBpc1V0Y09mZnNldDtcclxuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XHJcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xyXG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcclxuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XHJcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcclxuICAgICAgICAnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLFxyXG4gICAgICAgIGdldFNldERheU9mTW9udGhcclxuICAgICk7XHJcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXHJcbiAgICAgICAgZ2V0U2V0TW9udGhcclxuICAgICk7XHJcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcclxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXHJcbiAgICAgICAgZ2V0U2V0WWVhclxyXG4gICAgKTtcclxuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJyxcclxuICAgICAgICBnZXRTZXRab25lXHJcbiAgICApO1xyXG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcclxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcclxuICAgICk7XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XHJcblxyXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xyXG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSA9IGludmFsaWREYXRlO1xyXG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcclxuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XHJcbiAgICBwcm90byQxLnBvc3Rmb3JtYXQgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XHJcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcclxuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XHJcbiAgICBwcm90byQxLnNldCA9IHNldDtcclxuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XHJcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcclxuICAgIHByb3RvJDEuZXJhc0NvbnZlcnRZZWFyID0gbG9jYWxlRXJhc0NvbnZlcnRZZWFyO1xyXG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcclxuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XHJcbiAgICBwcm90byQxLmVyYXNOYXJyb3dSZWdleCA9IGVyYXNOYXJyb3dSZWdleDtcclxuXHJcbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcclxuICAgIHByb3RvJDEubW9udGhzU2hvcnQgPSBsb2NhbGVNb250aHNTaG9ydDtcclxuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcclxuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcclxuICAgIHByb3RvJDEubW9udGhzU2hvcnRSZWdleCA9IG1vbnRoc1Nob3J0UmVnZXg7XHJcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xyXG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xyXG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xyXG5cclxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcclxuICAgIHByb3RvJDEud2Vla2RheXNNaW4gPSBsb2NhbGVXZWVrZGF5c01pbjtcclxuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XHJcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xyXG5cclxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XHJcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcclxuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCA9IHdlZWtkYXlzTWluUmVnZXg7XHJcblxyXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcclxuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxyXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBvdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAoKVxyXG4gICAgLy8gKDUpXHJcbiAgICAvLyAoZm10LCA1KVxyXG4gICAgLy8gKGZtdClcclxuICAgIC8vICh0cnVlKVxyXG4gICAgLy8gKHRydWUsIDUpXHJcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxyXG4gICAgLy8gKHRydWUsIGZtdClcclxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xyXG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcclxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgb3V0ID0gW107XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMoZm9ybWF0LCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XHJcbiAgICAgICAgZXJhczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxyXG4gICAgICAgICAgICAgICAgdW50aWw6ICtJbmZpbml0eSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXHJcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdBRCcsXHJcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxyXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcclxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcclxuICAgICAgICAgICAgICAgIGFiYnI6ICdCQycsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcclxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICd0aCc7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcclxuXHJcbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXHJcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlXHJcbiAgICApO1xyXG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXHJcbiAgICAgICAgJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLFxyXG4gICAgICAgIGdldExvY2FsZVxyXG4gICAgKTtcclxuXHJcbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFicygpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcblxyXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcclxuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcclxuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XHJcblxyXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xyXG4gICAgICAgIGRhdGEubWludXRlcyA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcclxuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcclxuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xyXG4gICAgICAgIGRhdGEueWVhcnMgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcclxuICAgICAgICBkdXJhdGlvbi5fZGF5cyArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcclxuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XHJcblxyXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxyXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QkMShpbnB1dCwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xyXG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWJibGUoKSB7XHJcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcclxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXHJcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXHJcbiAgICAgICAgICAgIHNlY29uZHMsXHJcbiAgICAgICAgICAgIG1pbnV0ZXMsXHJcbiAgICAgICAgICAgIGhvdXJzLFxyXG4gICAgICAgICAgICB5ZWFycyxcclxuICAgICAgICAgICAgbW9udGhzRnJvbURheXM7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcclxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICEoXHJcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxyXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XHJcbiAgICAgICAgICAgIGRheXMgPSAwO1xyXG4gICAgICAgICAgICBtb250aHMgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxyXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cclxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XHJcblxyXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcclxuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XHJcblxyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xyXG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcclxuXHJcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xyXG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xyXG5cclxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xyXG5cclxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXHJcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xyXG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcclxuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XHJcblxyXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcclxuICAgICAgICBtb250aHMgJT0gMTI7XHJcblxyXG4gICAgICAgIGRhdGEuZGF5cyA9IGRheXM7XHJcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XHJcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xyXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcclxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcclxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XHJcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXHJcbiAgICAgICAgcmV0dXJuIChtb250aHMgKiAxNDYwOTcpIC8gNDgwMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcyh1bml0cykge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRheXMsXHJcbiAgICAgICAgICAgIG1vbnRocyxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xyXG5cclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuXHJcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xyXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xyXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXHJcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMjQgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXHJcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXHJcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xyXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlQXMoYWxpYXMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyksXHJcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXHJcbiAgICAgICAgYXNNaW51dGVzID0gbWFrZUFzKCdtJyksXHJcbiAgICAgICAgYXNIb3VycyA9IG1ha2VBcygnaCcpLFxyXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxyXG4gICAgICAgIGFzV2Vla3MgPSBtYWtlQXMoJ3cnKSxcclxuICAgICAgICBhc01vbnRocyA9IG1ha2VBcygnTScpLFxyXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcclxuICAgICAgICBhc1llYXJzID0gbWFrZUFzKCd5Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXHJcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcclxuICAgICAgICBtaW51dGVzID0gbWFrZUdldHRlcignbWludXRlcycpLFxyXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcclxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxyXG4gICAgICAgIG1vbnRocyA9IG1ha2VHZXR0ZXIoJ21vbnRocycpLFxyXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrcygpIHtcclxuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxyXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XHJcbiAgICAgICAgICAgIHNzOiA0NCwgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXHJcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxyXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXHJcbiAgICAgICAgICAgIGg6IDIyLCAvLyBob3VycyB0byBkYXlcclxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xyXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxyXG4gICAgICAgICAgICBNOiAxMSwgLy8gbW9udGhzIHRvIHllYXJcclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXHJcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCksXHJcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcclxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxyXG4gICAgICAgICAgICBob3VycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpLFxyXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXHJcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxyXG4gICAgICAgICAgICB3ZWVrcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd3JykpLFxyXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxyXG4gICAgICAgICAgICBhID1cclxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10pIHx8XHJcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XHJcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxyXG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdKSB8fFxyXG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XHJcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcclxuICAgICAgICAgICAgICAgIChkYXlzIDw9IDEgJiYgWydkJ10pIHx8XHJcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xyXG5cclxuICAgICAgICBpZiAodGhyZXNob2xkcy53ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYSA9XHJcbiAgICAgICAgICAgICAgICBhIHx8XHJcbiAgICAgICAgICAgICAgICAod2Vla3MgPD0gMSAmJiBbJ3cnXSkgfHxcclxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYSA9IGEgfHxcclxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxyXG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxyXG4gICAgICAgICAgICAoeWVhcnMgPD0gMSAmJiBbJ3knXSkgfHwgWyd5eScsIHllYXJzXTtcclxuXHJcbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XHJcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XHJcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcclxuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xyXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcocm91bmRpbmdGdW5jdGlvbikge1xyXG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xyXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkKHRocmVzaG9sZCwgbGltaXQpIHtcclxuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcclxuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcclxuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxyXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXHJcbiAgICAgICAgICAgIGxvY2FsZSxcclxuICAgICAgICAgICAgb3V0cHV0O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xyXG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XHJcbiAgICAgICAgICAgIGlmIChhcmdUaHJlc2hvbGRzLnMgIT0gbnVsbCAmJiBhcmdUaHJlc2hvbGRzLnNzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XHJcbiAgICAgICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIHRoLCBsb2NhbGUpO1xyXG5cclxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xyXG4gICAgICAgIHJldHVybiAoeCA+IDApIC0gKHggPCAwKSB8fCAreDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xyXG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XHJcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xyXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcclxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXHJcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcclxuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcclxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwLFxyXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXHJcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXHJcbiAgICAgICAgICAgIG1pbnV0ZXMsXHJcbiAgICAgICAgICAgIGhvdXJzLFxyXG4gICAgICAgICAgICB5ZWFycyxcclxuICAgICAgICAgICAgcyxcclxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxyXG4gICAgICAgICAgICB0b3RhbFNpZ24sXHJcbiAgICAgICAgICAgIHltU2lnbixcclxuICAgICAgICAgICAgZGF5c1NpZ24sXHJcbiAgICAgICAgICAgIGhtc1NpZ247XHJcblxyXG4gICAgICAgIGlmICghdG90YWwpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxyXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXHJcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xyXG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcclxuICAgICAgICBzZWNvbmRzICU9IDYwO1xyXG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XHJcblxyXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcclxuICAgICAgICBtb250aHMgJT0gMTI7XHJcblxyXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXHJcbiAgICAgICAgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xyXG5cclxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcclxuICAgICAgICB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XHJcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xyXG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXHJcbiAgICAgICAgICAgICdQJyArXHJcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcclxuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChkYXlzID8gZGF5c1NpZ24gKyBkYXlzICsgJ0QnIDogJycpICtcclxuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChtaW51dGVzID8gaG1zU2lnbiArIG1pbnV0ZXMgKyAnTScgOiAnJykgK1xyXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XHJcbiAgICBwcm90byQyLmFicyA9IGFicztcclxuICAgIHByb3RvJDIuYWRkID0gYWRkJDE7XHJcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcclxuICAgIHByb3RvJDIuYXMgPSBhcztcclxuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcclxuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xyXG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XHJcbiAgICBwcm90byQyLmFzSG91cnMgPSBhc0hvdXJzO1xyXG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XHJcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xyXG4gICAgcHJvdG8kMi5hc01vbnRocyA9IGFzTW9udGhzO1xyXG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcclxuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XHJcbiAgICBwcm90byQyLnZhbHVlT2YgPSB2YWx1ZU9mJDE7XHJcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XHJcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcclxuICAgIHByb3RvJDIuZ2V0ID0gZ2V0JDI7XHJcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcclxuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XHJcbiAgICBwcm90byQyLm1pbnV0ZXMgPSBtaW51dGVzO1xyXG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xyXG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcclxuICAgIHByb3RvJDIud2Vla3MgPSB3ZWVrcztcclxuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xyXG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xyXG4gICAgcHJvdG8kMi5odW1hbml6ZSA9IGh1bWFuaXplO1xyXG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XHJcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcclxuICAgIHByb3RvJDIudG9KU09OID0gdG9JU09TdHJpbmckMTtcclxuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xyXG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcclxuXHJcbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXHJcbiAgICAgICAgdG9JU09TdHJpbmckMVxyXG4gICAgKTtcclxuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XHJcblxyXG4gICAgLy8gRk9STUFUVElOR1xyXG5cclxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcclxuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcclxuXHJcbiAgICAvLyBQQVJTSU5HXHJcblxyXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcclxuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XHJcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcclxuICAgIH0pO1xyXG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyEgbW9tZW50LmpzXHJcblxyXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjEnO1xyXG5cclxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XHJcblxyXG4gICAgaG9va3MuZm4gPSBwcm90bztcclxuICAgIGhvb2tzLm1pbiA9IG1pbjtcclxuICAgIGhvb2tzLm1heCA9IG1heDtcclxuICAgIGhvb2tzLm5vdyA9IG5vdztcclxuICAgIGhvb2tzLnV0YyA9IGNyZWF0ZVVUQztcclxuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xyXG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcclxuICAgIGhvb2tzLmlzRGF0ZSA9IGlzRGF0ZTtcclxuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcclxuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xyXG4gICAgaG9va3MuZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbjtcclxuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XHJcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcclxuICAgIGhvb2tzLnBhcnNlWm9uZSA9IGNyZWF0ZUluWm9uZTtcclxuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XHJcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcclxuICAgIGhvb2tzLm1vbnRoc1Nob3J0ID0gbGlzdE1vbnRoc1Nob3J0O1xyXG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XHJcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XHJcbiAgICBob29rcy51cGRhdGVMb2NhbGUgPSB1cGRhdGVMb2NhbGU7XHJcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XHJcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XHJcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyA9IG5vcm1hbGl6ZVVuaXRzO1xyXG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcclxuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcclxuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XHJcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xyXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xyXG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxyXG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cclxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XHJcbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxyXG4gICAgICAgIFRJTUU6ICdISDptbScsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XHJcbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XHJcbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XHJcbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxyXG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gaG9va3M7XHJcblxyXG59KSkpO1xyXG4iLCJpbXBvcnQgeyBydW5UaW1lciB9IGZyb20gJy4vdGltZXInO1xuXG5ydW5UaW1lcigpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJy4uL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50JztcblxuY29uc3QgdGltZXJJbnB1dCA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lci1pbnB1dCcpO1xuY29uc3QgdGltZXJNb3JlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVyLW1vcmUtYnRuJyk7XG5jb25zdCB0aW1lckxlc3NCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZXItbGVzcy1idG4nKTtcblxudGltZXJNb3JlQnRuLm9uY2xpY2sgPSAoKSA9PiB7XG4gIGlmICghdGltZXJJbnB1dC52YWx1ZSkge1xuICAgIHRpbWVySW5wdXQudmFsdWUgPSAnMCc7XG4gIH1cbiAgbGV0IGlucHV0VGltZSA9IHBhcnNlSW50KHRpbWVySW5wdXQudmFsdWUsIDEwKTtcbiAgaW5wdXRUaW1lICs9IDE7XG4gIHRpbWVySW5wdXQudmFsdWUgPSBpbnB1dFRpbWUudG9TdHJpbmcoKTtcbn07XG50aW1lckxlc3NCdG4ub25jbGljayA9ICgpID0+IHtcbiAgbGV0IGlucHV0VGltZSA9IHBhcnNlSW50KHRpbWVySW5wdXQudmFsdWUsIDEwKTtcbiAgaWYgKGlucHV0VGltZSA+IDApIHtcbiAgICBpbnB1dFRpbWUgLT0gMTtcbiAgICB0aW1lcklucHV0LnZhbHVlID0gaW5wdXRUaW1lLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgYWxlcnQoJ1dhbm5hIGdvIGJhY2sgaW4gdGltZT8gR29vZCBsdWNrIHdpdGggdGhhdCEnKTtcbiAgfVxufTtcblxudGltZXJJbnB1dC5vbmlucHV0ID0gKCkgPT4ge1xuICBpZiAoTnVtYmVyLmlzTmFOKHBhcnNlSW50KHRpbWVySW5wdXQudmFsdWUsIDEwKSkpIHtcbiAgICBhbGVydCgnV2hhdCBraW5kIG9mIHRpbWUgaXMgdGhhdD8nKTtcbiAgICB0aW1lcklucHV0LnZhbHVlID0gJzAnO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcnVuVGltZXIoKSB7XG4gIGxldCB1c2Vyc1RpbWU7XG4gIGNvbnN0IHN0YXJ0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0Jyk7XG4gIHN0YXJ0Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgdXNlcnNUaW1lID0gdGltZXJJbnB1dC52YWx1ZTtcbiAgICBjb25zdCB0aW1lID0gbW9tZW50KHsgbWludXRlOiBwYXJzZUludCh1c2Vyc1RpbWUsIDEwKSwgc2Vjb25kOiAwIH0pO1xuICAgIGNvbnN0IHRpbWVyVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lci10ZXh0Jyk7XG4gICAgdGltZXJUZXh0LmlubmVySFRNTCA9ICfQntGB0YLQsNC70L7RgdGMOic7XG4gICAgY29uc3QgdGltZXJNZW51ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVyLW1lbnUnKTtcbiAgICB0aW1lck1lbnUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBzdGFydC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGNvbnN0IHRpbWVyT3V0cHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGltZXJPdXRwdXQuY2xhc3NMaXN0LmFkZCgndGltZXItb3V0cHV0Jyk7XG4gICAgY29uc3QgdGltZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZXInKTtcbiAgICB0aW1lci5hcHBlbmRDaGlsZCh0aW1lck91dHB1dCk7XG5cbiAgICB0aW1lck91dHB1dC5pbm5lckhUTUwgPSB0aW1lLmZvcm1hdCgnbW06c3MnKTtcbiAgICBjb25zdCB0aW1pbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBuZXdUaW1lID0gdGltZS5zdWJ0cmFjdCgxLCAnc2Vjb25kcycpO1xuICAgICAgdGltZXJPdXRwdXQuaW5uZXJIVE1MID0gbmV3VGltZS5mb3JtYXQoJ21tOnNzJyk7XG4gICAgfSwgMTAwMCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWluZyk7XG4gICAgfSwgcGFyc2VJbnQodXNlcnNUaW1lLCAxMCkgKiAxMDAwICogNjApO1xuICB9O1xufVxuIl19"}